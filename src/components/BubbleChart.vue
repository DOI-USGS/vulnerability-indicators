<template>
        <div id="chart-container">
        </div>
</template>
  
<script setup>
    import { onMounted, ref } from "vue";
    import * as d3 from 'd3';

    // global variables 
    const publicPath = import.meta.env.BASE_URL;
    const data = ref([]); 

    // load data and then make chart
    onMounted(() => {
        loadData().then(() => {
            if (data.value.length > 0) {
            createBubbleChart();
            }
        });
    });

    async function loadData() {
        data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', d => {
            d.level_agreement = +d.level_agreement; 
            d.evidence_val = +d.evidence_val; 
            return d;
        });
        }

    function createBubbleChart() {
        // ... SVG setup ...
        const width = 1000; // Set your width
        const height = 800; // Set your height
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };

        const svg = d3.select("#chart-container")
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height);

        // Define scales and axes
        const categories = Array.from(new Set(data.value.map(d => d.dimension))); // Unique categories
        const categoryCenters = {};
        const spacing = width / (categories.length + 1);

        // positioning for the bubble clusters
        const numRows = 2//Math.ceil(Math.sqrt(categories.length)); // Number of rows for grid layout
        const numCols = 4//Math.ceil(categories.length / numRows); // Number of columns
        const colWidth = width / numCols;
        const rowHeight = height / numRows;

        categories.forEach((category, index) => {
            let col = index % numCols;  // Column index
            let row = Math.floor(index / numCols);  // Row index

            // Offset columns in the second row
            if (row === 1) {
                col += 0.5;  // Offset by half a column width
            }

            // Calculate the center position
            categoryCenters[category] = { 
                x: colWidth * col + colWidth / 2, 
                y: rowHeight * row + rowHeight / 2 
            };
        });

        // color scale for dimensions
        const colorScale = d3.scaleOrdinal(d3.schemeDark2)
            .domain(categories)
        // to manually select the colors
            //const colorScale = d3.scaleOrdinal()
        //    .domain(['category1', 'category2', 'category3', ...])
        //    .range(['#1f77b4', '#ff7f0e', '#2ca02c', ...]); // Using the set of distinct colors

        // scale bubble size to evidence
        const radiusScale = d3.scaleLinear()
            .domain([d3.min(data.value, d => d.evidence_val), d3.max(data.value, d => d.evidence_val)])
            .range([10, 50]);

        // set starting positions for bubbles when they first appear
        data.value.forEach(d => {
            // Add randomness to the initial positions
            const center = categoryCenters[d.dimension];
            d.x = center.x + (Math.random() - 0.5) * 50; // Adjust randomness factor (50 here) as needed
            d.y = center.y + (Math.random() - 0.5) * 50;
        });

        // define forces that control the bubbles
        const forceX = d3.forceX(d => categoryCenters[d.dimension].x).strength(0.2);
        const forceY = d3.forceY(d => categoryCenters[d.dimension].y).strength(0.1);
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 2);
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed

        // add bubbles to the page
        const bubbles = svg.selectAll(".bubble")
            .data(data.value)
            .enter().append("circle")
            .attr("class", "bubble")
            .attr('r', d => radiusScale(d.evidence_val))
            .style('fill',  d => colorScale(d.dimension));

        // add mouseover effect 
        bubbles
            .on("mouseover", handleMouseOver)
            .on("mousemove", handleMouseMove)
            .on("mouseout", handleMouseOut);

        // run force simulation
        const simulation = d3.forceSimulation()
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .nodes(data.value)
            .on("tick", ticked)
            .alpha(.2)
            .restart();

        // ticking function to move bubbles from initial position to resting (I think this is what it's doing?)
        function ticked() {
            bubbles
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }

        // drag n drop effect
        const drag = d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);

            bubbles.call(drag);

        // let the user move them around, but pull back to their resting spot
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
           
        // basic tooltip styling 
        const tooltip = d3.select("#chart-container")
            .append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("font-size", "16px") // Style as needed
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px")
            .style("position", "absolute")
            .style("pointer-events", "none")

        // TODO: use animation to fade in and look nice
        // position tooltip based on pointer. change opacity of bubble when mouseMove
        function handleMouseOver(event, d) {
            tooltip
                .transition().duration(200)
                .style("opacity", 1);
        }

        function handleMouseMove(event, d) {
            const [x, y] = d3.pointer(event); 
            const containerRect = document.getElementById('chart-container').getBoundingClientRect();
            console.log(containerRect);
            tooltip
                .html(`${d.determinant}`)
                .style("left", (x) + "px")
                .style("top", (y) + "px");
                // console.log("left/X: ", x, " right/Y: ", y);
            d3.select(this)
                .style("opacity", 0.8);
        }

        function handleMouseOut() {
            tooltip
                .transition().duration(200)
                .style("opacity", 0);
            d3.select(this)
                .style("opacity", 1);
        }

}



</script>
  
<style scoped lang="scss">
.bubble {
    stroke: black; /* Dark outline */
    stroke-width: 2px; /* Thicker outline */
    fill-opacity: 0.8; /* Higher fill opacity */
}

#chart-container {
    text-align: center;
    position: relative;
}

#chart-container svg {
    max-width: 100%;
    max-height: 100%;
    height: auto; /* Maintain aspect ratio */
    display: inline-block;
}

.chart-text {
    user-select: none;
}

</style>

  