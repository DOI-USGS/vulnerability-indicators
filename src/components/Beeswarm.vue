<template>
    <section id="beeswarm">
        <div
            id="title"
            class="text-container title-text"
        >
            <h3 v-html="agVsMunText.title" />
        </div>
        <div
            id="text1"
            class="text-container"
        >
            <p v-html="agVsMunText.paragraph1" />
        </div>
        <div id="button-container">
                <button @click="resetBubbles()">1 swarm</button>
                <button @click="categorizeBubbles()">3 swarms</button>
        </div>
        <div id="beeswarm-chart-container">
            
        </div>
        <div
            id="title2"
            class="text-container title-text"
        >
            <h3 v-html="vulnerabilityText.title" />
        </div>
        <div
            id="text2"
            class="text-container"
        >
            <p v-html="vulnerabilityText.paragraph1" />
        </div>
        <div
            id="text3"
            class="text-container"
        >
            <p v-html="vulnerabilityText.paragraph2" />
        </div>
        <div
            id="text4"
            class="text-container"
        >
            <p v-html="vulnerabilityText.paragraph3" />
        </div>
    </section>
</template>
  
<script setup>
    import { onMounted, ref } from "vue";
    import { isMobile } from 'mobile-device-detect';
    import * as d3 from 'd3';
    import agVersusMunicipalText from "./../assets/text/agVsMunicipalText";
    import socialVulnerabilityText from "./../assets/text/socialVulnerabilityText"
    

    // global variables 
    const publicPath = import.meta.env.BASE_URL;
    const data = ref([]);
    const agVsMunText = agVersusMunicipalText.agVersusMunicipalText;
    const vulnerabilityText= socialVulnerabilityText.socialVulnerabilityText;
    let simulation; 
    let svg

    // load data and then make chart
    onMounted(() => {
        loadData().then(() => {
            if (data.value.length > 0) {
            createBubbleChart();
            }
        });
    });

    async function loadData() {
        data.value = await d3.csv(publicPath + 'p2_agree_evid_stats.csv', d => { // using 'indicator_uncertainty.csv' instead doesn't separate by indicators and has fewer bubbles
            d.level_agreement = +(+d.level_agreement).toFixed(2); 
            d.evidence_val = +d.evidence_val; 
            return d;
        });
    };

    function createBubbleChart() {
        const height = 800;
        const width = 1000;
        let margin = {top: 100, right: 20, bottom: 20, left: 40}

        const dimensionColors = {
            DemographicCharacteristics: "#625D0B",
            LandTenure: "#5C0601",
            LivingConditions: "#0B4E8B",
            SocioeconomicStatus: "#DC8260",
            Health: "#7F4A89",
            RiskPerception: "#249CB1",
            Exposure: "#B47D83"
        }

        svg = d3.select("#beeswarm-chart-container")
            .append('svg')
            .attr('width', width)
            .attr('height', height);

        // set x axis scale based on level of agreement
        const xScale = d3.scaleLinear()
            .domain([40, d3.max(data.value, d => d.level_agreement)])
            .range([margin.left, width-80]);
                
        // set radius based on evidence value
        const radiusScale = d3.scaleLinear()
            .domain([d3.min(data.value, d => d.evidence_val), d3.max(data.value, d => d.evidence_val)])
            .range([10, 50]);

        // add xAxis g to svg
        const xAxis = svg.append('g')
            .attr("transform", "translate(0," + (height - margin.bottom) + ")")
            .call(d3.axisBottom(xScale))


        // define forces that control the bubbles
        const forceX = d3.forceX(d => xScale(d.level_agreement)).strength(1);
        const forceY = d3.forceY((height/1.5) - (margin.bottom/2))//.strength(0.1);
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 2); //forceCollide for bubbles sized by evidence_val
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed

       
        const bubbles = svg.selectAll(".bubble")
            .data(data.value)
            .enter().append("circle")
            .attr("class", d => "bubble " + d.dimension.replace(" ", ""))
            .attr('r', d => radiusScale(d.evidence_val)) // size bubbles based on evidence_val
            .style('fill', d => dimensionColors[d.dimension.replace(" ", "")]);
        
        bubbles
            .on("mouseover", handleMouseOver)
            .on("mousemove", handleMouseMove)
            .on("mouseout", handleMouseOut);

        // run force simulation
        simulation = d3.forceSimulation()
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .nodes(data.value)
            .on("tick", ticked)
            .alpha(.2)
            .restart();

        function ticked() {
            bubbles
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }

        // create tooltip
        const tooltip = d3.select("#beeswarm-chart-container")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        function handleMouseOver(event, d) {
            tooltip
                .transition().duration(200)
                .style("opacity", 1);
        }

        function handleMouseMove(event, d) {
            const [x, y] = d3.pointer(event); 
            const containerRect = document.getElementById('beeswarm-chart-container').getBoundingClientRect();
            // console.log(containerRect);
            tooltip
                .html(`${d.determinant}, Level of Agreement: ${d.level_agreement}`) 
                .style("left", (x) + "px")
                .style("top", (y) + "px");
                // console.log("left/X: ", x, " right/Y: ", y);
            d3.selectAll(".bubble")
                .filter(function(e) { return e.dimension !== d.dimension; }) // change the opacity of bubbles that do not have the same dimension as the selected bubble
                .style("opacity", 0.3);
        }

        function handleMouseOut(d) {
            tooltip
                .transition().duration(200)
                .style("opacity", 0);
            d3.selectAll(".bubble")
                .filter(function(e) { return e.dimension !== d.dimension; })
                .style("opacity", 1);
        }
       
    }

    function categorizeBubbles() {
        const height = 800;
        const width = 1000;
        let margin = {top: 100, right: 20, bottom: 20, left: 40}

        // set x axis scale based on level of agreement
        const xScale = d3.scaleLinear()
            .domain([40, d3.max(data.value, d => d.level_agreement)])
            .range([margin.left, width-80]);

        var yScale = d3.scaleBand()
            .domain(data.value.map(function(d) { return d.sig_name; }))
            .range([margin.top, height-margin.bottom])
            // .padding(0.1);

        const radiusScale = d3.scaleLinear()
            .domain([d3.min(data.value, d => d.evidence_val), d3.max(data.value, d => d.evidence_val)])
            .range([10, 40]);


        // define forces that control the bubbles
        const forceX = d3.forceX(d => xScale(d.level_agreement)).strength(.3);
        const forceY = d3.forceY(d => yScale(d.sig_name)).strength(.3)
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 3); //forceCollide for bubbles sized by evidence_val
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed

        simulation
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .alpha(.2)
            .restart();

        const uniqueSigNames = [...new Set(data.value.map(d => d.sig_name.replace(/_/g, ' ')))];
        console.log(uniqueSigNames);
        const numCategories = uniqueSigNames.length;
        const swarmHeight = height / numCategories;

        const categoryLabels = svg.selectAll(".category-label")
            .data(uniqueSigNames)
            .enter()
            .append("text")
            .attr("class", "category-label")
            .attr("x", width/2) // Position labels in the center of each swarm
            .attr("y", (d, i) => swarmHeight * (i + 0.5)) // Adjust as needed to position above the swarms
            .attr("text-anchor", "middle")
            .text(d => d);
    }

    function resetBubbles() {
        console.log("Inside resetBubbles");
        const height = 800;
        const width = 1000;
        let margin = {top: 100, right: 20, bottom: 20, left: 40}

        const xScale = d3.scaleLinear()
            .domain([40, d3.max(data.value, d => d.level_agreement)])
            .range([margin.left, width-80]);
                
        // set radius based on evidence value
        const radiusScale = d3.scaleLinear()
            .domain([d3.min(data.value, d => d.evidence_val), d3.max(data.value, d => d.evidence_val)])
            .range([10, 50]);

        // define forces that control the bubbles
        const forceX = d3.forceX(d => xScale(d.level_agreement)).strength(1);
        const forceY = d3.forceY((height/1.5) - (margin.bottom/2))//.strength(0.1);
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 2); //forceCollide for bubbles sized by evidence_val
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed

        simulation
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .alpha(.2)
            .restart();
    }

</script>
  
<style scoped lang="scss">

.bubble {
    stroke: black;
    stroke-width: 2px; 
    fill-opacity: 0.8; 
}

#beeswarm-chart-container {
    text-align: center;
    position: relative;
}

#beeswarm-chart-container svg {
    max-width: 100%;
    max-height: 100%;
    height: auto; /* Maintain aspect ratio */
    display: inline-block;
}

.chart-text {
    user-select: none;
}

#button-container {
    display: flex;
    justify-content: center;
    margin-top: 20px;
}

#button-container button {
    margin: 0 10px; 
}


</style>

  