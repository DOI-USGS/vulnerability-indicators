<template>
    <section id="beeswarm">
        <div
            id="title"
            class="text-container title-text"
        >
            <h3 v-html="agVsMunText.title" />
        </div>
        <div
            id="text1"
            class="text-container"
        >
            <p v-html="agVsMunText.paragraph1" />
        </div>
        <div 
            id="toggle-container"
            class="text-container"
            aria-hidden="true"
        >
            <div class="graph-buttons-switch">
                <input
                    id="id_dataSet1"
                    type="radio"
                    class="graph-buttons-switch-input"
                    name="dataSet1"
                    value="dataSet1"
                    checked
                >
                <label
                    id="dataSet1"
                    for="id_dataSet1"
                    tabindex="0"
                    class="graph-buttons-switch-label graph-buttons-switch-label-off"
                >Determinant</label>
                <input
                    id="id_dataSet2"
                    type="radio"
                    class="graph-buttons-switch-input"
                    name="dataSet2"
                    value="dataSet2"
                >
                <label
                    id="dataSet2"
                    for="id_dataSet2"
                    tabindex="0"
                    class="graph-buttons-switch-label graph-buttons-switch-label-on"
                >Indicator</label>
                <span class="graph-buttons-switch-selection" />
            </div>
        </div>

        <!-- <div id="button-container">
                <button @click="toggleDataset">Toggle Dataset</button>
        </div> -->
        <div id="beeswarm-chart-container">
            
        </div>
        <div
            id="title2"
            class="text-container title-text"
        >
            <h3 v-html="vulnerabilityText.title" />
        </div>
        <div
            id="text2"
            class="text-container"
        >
            <p v-html="vulnerabilityText.paragraph1" />
        </div>
        <div
            id="text3"
            class="text-container"
        >
            <p v-html="vulnerabilityText.paragraph2" />
        </div>
        <div
            id="text4"
            class="text-container"
        >
            <p v-html="vulnerabilityText.paragraph3" />
        </div>
    </section>
</template>
  
<script setup>
    import { onMounted, ref } from "vue";
    import { isMobile } from 'mobile-device-detect';
    import * as d3 from 'd3';
    import agVersusMunicipalText from "./../assets/text/agVsMunicipalText";
    import socialVulnerabilityText from "./../assets/text/socialVulnerabilityText"
    

    // global variables 
    const publicPath = import.meta.env.BASE_URL;
    const agVsMunText = agVersusMunicipalText.agVersusMunicipalText;
    const vulnerabilityText= socialVulnerabilityText.socialVulnerabilityText;
    const dataSet1 = ref([]); 
    const dataSet2 = ref([]); 
    let data = dataSet1
    let simulation; 
    let svg  

    const height = 600;
    const width = 1000;
    let margin = {top: 100, right: 20, bottom: 20, left: 40}

    // const svg = d3.select("#beeswarm-chart-container")
    //     .append('svg')
    //     .attr('class', 'beeswarmSvg')
    //     .attr('width', width)
    //     .attr('height', height);
    
    // set colors for bubble charts
    const dimensionColors = {
            Demographiccharacteristics: "#625D0B",
            Landtenure: "#5C0601",
            Livingconditions: "#0B4E8B",
            Socioeconomicstatus: "#DC8260",
            Health: "#7F4A89",
            Riskperception: "#249CB1",
            Exposure: "#B47D83"
        }

    // function initializeToggle() {
    //   console.log("initializeToggle");

    //   if (document.readyState !== 'loading') {
    //     console.log('document is already ready, just execute code here');
    //     addToggle();
    //   } else {
    //   document.addEventListener('DOMContentLoaded', function () {
    //     console.log('document was not ready, place code here');
    //     addToggle();
    //   });
    //   }
    // }

    // load data and then make chart
    onMounted(() => {
      console.log("component mounted");
        loadDatasets().then(() => {
            if (data.value.length > 0) {
                addToggle()
                createBubbleChart(data);
            } else {
                console.error('Error loading data:', error)
            }
        });
    });

    async function loadDatasets() {
        dataSet1.value = await loadData('determinant_uncertainty.csv');
        dataSet2.value = await loadData('indicator_uncertainty.csv')
        // console.log(dataSet1.value);
        // console.log(dataSet2.value);
    }

    async function loadData(fileName) {
        return await d3.csv(publicPath + fileName, d => { 
            d.level_agreement = +(+d.level_agreement).toFixed(2); 
            d.evidence_val = +d.evidence_val; 
            d.sig_value = +d.sig_value; 
            return d;
        });
    };

    // function toggleDataset() {
    //     data = data === dataSet1 ? dataSet2 : dataSet1;
    //     if (data == dataSet2) {
    //         categorizeBubbles(dataSet2)
    //     } else {
    //         resetBubbles(dataSet1)
    //     }
    // }

    function addToggle() {
      console.log("addToggle");
      // https://codepen.io/meijer3/pen/WzweRo

        const toggleLabels = d3.selectAll('.graph-buttons-switch-label')
        
        toggleLabels.on("mousedown touchstart", function(event) {
          console.log(toggleLabels);

          const dragger = d3.select(this.parentNode);
          console.log(dragger);
          let startx = 0;
          let touchEndX = 0;
      
          dragger
            // The touchstart and touchmove events allow the white box to be dragged within the toggle on mobile
            .on("touchstart", function(event) {
              // only triggered on mobile
              startx = d3.pointer(event.touches[0])[0]
              // If start on right, correct
              startx = (startx < dragger.select('label').node().getBoundingClientRect().width)? startx : startx - (dragger.select('label').node().getBoundingClientRect().width)
            })
            .on("touchmove", function(event) {
              // only triggered on mobile
              let xcoord = d3.pointer(event.touches[0])[0] - startx

              xcoord = ( xcoord > dragger.select('label').node().getBoundingClientRect().width) ? dragger.select('label').node().getBoundingClientRect().width : xcoord
              xcoord = ( xcoord < 0) ? 2 : xcoord
              dragger.select('.graph-buttons-switch-selection').attr('style','left:' + xcoord + 'px;');
              touchEndX = xcoord
            })
            .on("touchend", function (event) {
              // only triggered on mobile
              dragger.on("mousedown touchstart", null)
              dragger.on("touchmove mousemove", null) 
              dragger.on("mouseup touchend", null)
              
              // Get x coordinate of pointer event
              const xcoord = touchEndX

              //  coordinate over width of first label? 0 left | 1 right
              const id = (xcoord < dragger.select('label').node().getBoundingClientRect().width) ? 0 : 1;
              const altID = id === 0 ? 1 : 0

              const chos = dragger.selectAll('input').filter(function(d, i) { return i == id; })
              chos.node().checked = true;
              
              //remove styling
              dragger.select('.graph-buttons-switch-selection').attr('style','');
              
              // Do action
              // self.drawBarplot(chos.node().value)
            })
            .on("mouseup", function (event) {
              // console.log("hello")
              // triggered on desktop and mobile
              dragger.on("mousedown touchstart", null)
              dragger.on("touchmove mousemove", null) 
              dragger.on("mouseup touchend", null)

              // Get x coordinate of pointer event
              const xcoord = d3.pointer(event)[0]
              // console.log(xcoord);

              //  coordinate over width of first label? 0 left | 1 right
              const id = (xcoord < dragger.select('label').node().getBoundingClientRect().width) ? 0 : 1;
              // const altID = id === 0 ? 1 : 0
              console.log(id);

              const chos = dragger.selectAll('input').filter(function(d, i) { return i == id; })
              console.log(chos.node());
              chos.node().checked = true;
              console.log(chos.node().checked);
              console.log(chos.node());

              //remove styling
              dragger.select('.graph-buttons-switch-selection').attr('style','');
              
              if (chos.node().value === "dataSet2") {
                categorizeBubbles(dataSet2)
              } else {
                resetBubbles(dataSet1)
              }
              // // Do action
              // self.drawBarplot(chos.node().value)
            });
        })

        toggleLabels.each(function() {
          this.addEventListener("keypress", function(event) {
            if (event.key === 'Enter' | event.keyCode === 13) {
              let targetId = event.target.id

              // Shift toggle
              const chos = document.getElementById("id_" + targetId)
              chos.checked = true;

              if (chos.ATTRIBUTE_NODEvalue === "dataSet2") {
                categorizeBubbles(dataSet2)
              } else {
                resetBubbles(dataSet1)
              }
            }
          })
        })
    }

    // helper function to set up mouse events
    function createMouseEvents() {
        const tooltip = d3.selectAll('#beeswarm-chart-container')
        // const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        function handleMouseOver(event, d) {
            tooltip
                .transition().duration(200)
                .style("opacity", 1);
        }

        function handleMouseMove(event, d) {
            const [x, y] = d3.pointer(event); 
            // console.log(x, y);
            tooltip
                .html(`${d.determinant}, Level of Agreement: ${d.level_agreement}`) 
                .style("left", x + "px")
                .style("top", y + "px");
                // console.log("left/X: ", x, " right/Y: ", y);
            d3.selectAll(".bubble")
                .filter(function(e) { return e.dimension !== d.dimension; }) // change the opacity of bubbles that do not have the same dimension as the selected bubble
                .style("opacity", 0.3);
        }

        function handleMouseOut(d) {
            tooltip
                .transition().duration(200)
                .style("opacity", 0);
            d3.selectAll(".bubble")
                .filter(function(e) { return e.dimension !== d.dimension; })
                .style("opacity", 1);
        }

        return {handleMouseOver, handleMouseMove, handleMouseOut}
    }
    
    // call helper function
    const { handleMouseOver, handleMouseMove, handleMouseOut } = createMouseEvents();

    function createScales(data) {
        // set x axis scale based on level of agreement
        const xScale = d3.scaleLinear()
            .domain([40, d3.max(data.value, d => d.level_agreement)])
            .range([margin.left+ 125, width-100]);
                
        // set radius based on evidence value
        const radiusScale = d3.scaleLinear()
            .domain([d3.min(data.value, d => d.evidence_val), d3.max(data.value, d => d.evidence_val)])
            .range([10, 50]);

        return { xScale, radiusScale}
    }

    // initiate chart with determinant indicator dataset
    function createBubbleChart() {
        svg = d3.selectAll('#beeswarm-chart-container')
            .append('svg')  // TO DO if I can figure out how to take this out of createBubbleChart we can reuse this instead of resetBubbles repeating code.
            .attr('class', 'beeswarmSvg')
            .attr('width', width)
            .attr('height', height);

        const { xScale, radiusScale} = createScales(data);

        // add xAxis g to svg
        const xAxis = svg.append('g')
            .attr("transform", "translate(0," + (height - 50) + ")")
            .call(d3.axisBottom(xScale))

        // add label to x axis
        svg.append('text')
            .attr("class", "xLabel")
            .attr("text-anchor", "middle")
            .attr("x", width/2)
            .attr("y", height-10)
            .text("Level of Agreement");

        // define forces that control the bubbles
        const forceX = d3.forceX(d => xScale(d.level_agreement)).strength(1);
        const forceY = d3.forceY((height/1.5) - (margin.bottom/2))//.strength(0.1);
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 2); //forceCollide for bubbles sized by evidence_val
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed
       
        const bubbles = svg.selectAll(".bubble")
            .data(data.value)
            .enter().append("circle")
            .attr("class", d => "bubble " + d.dimension.replace(" ", ""))
            .attr('r', d => radiusScale(d.evidence_val)) // size bubbles based on evidence_val
            .style('fill', d => dimensionColors[d.dimension.replace(" ", "")]);
        
        // run force simulation
        simulation = d3.forceSimulation()
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .nodes(data.value)
            .on("tick", ticked)
            .alpha(.2)
            .restart();

        bubbles
            .on("mouseover", handleMouseOver)
            .on("mousemove", handleMouseMove)
            .on("mouseout", handleMouseOut);

        function ticked() {
            bubbles
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }       
    }

    // takes indicator_uncertainty.csv and categorizes bubbles by agreement direction
    function categorizeBubbles(data) {
        //remove determinant uncertainty bubbles
        svg.selectAll(".bubble").remove();

        const { xScale, radiusScale} = createScales(data);

        //separate beeswarms along the y axis based on agreement direction
        var yScale = d3.scaleBand()
            .domain(data.value.map(function(d) { return d.sig_name; }))
            .range([margin.top, height])

            // Add new bubbles with updated data
        const bubbles = svg.selectAll(".bubble")
            .data(data.value)
            .enter().append("circle")
            .attr("class", d => "bubble " + (d.dimension.replace(" ", "")) + " " + (d.indicator.replace(" ", "")) + " " + (d.sig_name))
            .attr('r', d => radiusScale(d.sig_value))
            .style('fill', d => dimensionColors[d.dimension.replace(" ", "")]);

        // define forces that control the bubbles
        const forceX = d3.forceX(d => xScale(d.level_agreement)).strength(.4);
        const forceY = d3.forceY(d => yScale(d.sig_name)).strength(.4)
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 1); //forceCollide for bubbles sized by evidence_val
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed

        // run force simulation
        simulation = d3.forceSimulation()
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .nodes(data.value)
            .on("tick", ticked)
            .alpha(.2)
            .restart();

        bubbles
            .on("mouseover", handleMouseOver)
            .on("mousemove", handleMouseMove)
            .on("mouseout", handleMouseOut);

        function ticked() {
            bubbles
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }

        // labeling categories
        // const uniqueSigNames = [...new Set(data.value.map(d => d.sig_name.replace(/_/g, ' ')))];
        const uniqueSigNames = ["Positively Related", "Negatively Related", "Unknown Direction"]
        const numCategories = uniqueSigNames.length;
        const swarmHeight = height / numCategories;

        const categoryLabels = svg.selectAll(".category-label")
            .data(uniqueSigNames)
            .enter()
            .append("text")
            .attr("class", "category-label")
            .attr("x", margin.right+100) // Position labels in the center of each swarm
            .attr("y", (d, i) => swarmHeight * (i + .2)) // Adjust as needed to position above the swarms
            .attr("text-anchor", "middle")
            .text(d => d)
            .style("opacity", 1);
    }

    // resets the bubbles using determinant_indicators.csv
    function resetBubbles(data) {
        // remove indicator uncertainty bubbles and category labels
        svg.selectAll(".bubble").remove();
        svg.selectAll(".category-label").remove();

        const { xScale, radiusScale} = createScales(data);

        // Add new bubbles with updated data
        const bubbles = svg.selectAll(".bubble")
            .data(data.value)
            .enter().append("circle")
            .attr("class", d => "bubble " + d.dimension.replace(" ", ""))
            .attr('r', d => radiusScale(d.evidence_val))
            .style('fill', d => dimensionColors[d.dimension.replace(" ", "")]);

        // define forces that control the bubbles
        const forceX = d3.forceX(d => xScale(d.level_agreement)).strength(1);
        const forceY = d3.forceY((height/1.5) - (margin.bottom/2))//.strength(0.1);
        const forceCollide = d3.forceCollide(d => radiusScale(d.evidence_val) + 2); //forceCollide for bubbles sized by evidence_val
        const forceManyBody = d3.forceManyBody().strength(-15); // Adjust the strength as needed

        // run force simulation
        simulation = d3.forceSimulation()
            .force("x", forceX)
            .force("y", forceY)
            .force("collide", forceCollide)
            .force("charge", forceManyBody)
            .nodes(data.value)
            .on("tick", ticked)
            .alpha(.2)
            .restart();
        
        bubbles
            .on("mouseover", handleMouseOver)
            .on("mousemove", handleMouseMove)
            .on("mouseout", handleMouseOut);

        function ticked() {
            bubbles
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }

        // hide agreement category labels
        const categoryLabels = svg.selectAll(".category-label")
            .style("opacity", 0);

    }

</script>
  
<style scoped lang="scss">
$switchWidth: 12rem;

#toggle-container {
    display: flex;
    width: 100%;
}

.graph-buttons-switch {
    display: flex;
    height: 2.8rem;
    width: $switchWidth * 2.03;
    border-radius: 0.2rem;
    position: relative;
    margin: 0rem 0.5rem 0rem 0.5rem;
    background: rgba(0, 0, 0, 0.3);
    -webkit-box-shadow: inset 0 0.1rem 0.3rem rgba(0, 0, 0, 0.1), 0 0.1remx rgba(255, 255, 255, 0.1);
    box-shadow: inset 0 0.1rem 0.3rem rgba(0, 0, 0, 0.1), 0 0.1rem rgba(255, 255, 255, 0.1);

      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
      -khtml-user-select: none; /* Konqueror HTML */
        -moz-user-select: none; /* Firefox */
          -ms-user-select: none; /* Internet Explorer/Edge */
              user-select: none; /* Non-prefixed version, currently
                                    supported by Chrome and Opera */
    @media screen and (max-width: 600px) {
      height: 2.6rem;
    }
  }
  .graph-buttons-switch-label {
    position: relative;
    z-index: 2;
    float: left;
    width: $switchWidth;
    line-height: 2.4rem;
    text-align: center;
    cursor: pointer;
    @media screen and (max-width: 600px) {
      line-height: 2.2rem;
      width: $switchWidth * 1.02;
    }
  }
  .graph-buttons-switch-label-off {
    padding-left: 0.2rem;
    padding-right: 0.2rem;
  }
  .graph-buttons-switch-label-on {
    padding-left: 0.2rem;
    padding-right: 0.2rem;
  }
  .graph-buttons-switch-input {display: none;}
  .graph-buttons-switch-input:checked + .graph-buttons-switch-label {
    font-weight: bold;
    -webkit-transition: 0.3s ease-out;
    -moz-transition: 0.3s ease-out;
    -o-transition: 0.3s ease-out;
    transition: 0.3s ease-out;
  }
  .graph-buttons-switch-input:checked + .graph-buttons-switch-label-on ~ .graph-buttons-switch-selection {left: $switchWidth;}

  .graph-buttons-switch-selection {
    display: block;
    position: absolute;
    z-index: 1;
    top: 0.2rem;
    left: 0.2rem;
    width: $switchWidth;
    height: 2.4rem;
    background: rgba(255, 255, 255,1);
    border-radius: 0.2rem;
    -webkit-box-shadow: inset 0 0.1rem rgba(255, 255, 255,0.6), 0 0 0.2rem rgba(0, 0, 0, 0.3);
    box-shadow: inset 0 0.1rem rgba(255, 255, 255,0.6), 0 0 0.2rem rgba(0, 0, 0, 0.3);
    -webkit-transition: left 0.3s ease-out,background 0.3s;
    -moz-transition: left 0.3s ease-out,background 0.3s;
    -o-transition: left 0.3s ease-out,background 0.3s;
    transition: left 0.3s ease-out,background 0.3s ;
  /* 	transition: background 0.3s ; */
    @media screen and (max-width: 600px) {
      height: 2.2rem;
    }
  }

#beeswarm-chart-container {
    text-align: center;
    position: relative;
}

#beeswarm-chart-container svg {
    max-width: 100%;
    max-height: 100%;
    height: auto; /* Maintain aspect ratio */
    display: inline-block;
}

.bubble {
    stroke: black;
    stroke-width: 2px; 
    fill-opacity: 0.8; 
}

.chart-text {
    user-select: none;
}

// #button-container {
//     display: flex;
//     justify-content: center;
//     margin-top: 20px;
// }

// #button-container button {
//     margin: 0 10px; 
// }

.tooltip {
    font-size: 16px;
    background-color: white;
    border: solid;
    border-width: 2px;
    border-radius: 5px;
    padding: 5px;
    position: absolute;
    // pointer-events: none;
}

// TO DO: not working
text.xLabel  {
    font-weight: 600;
}

</style>

  