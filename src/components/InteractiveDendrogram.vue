<template>
  <section id="dendrogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="metaText.title" />
    </div>
    <div id="text1" class="text-container">
      <p v-html="metaText.paragraph1" />
    </div>
    <div id="dendrogram-container"></div>
    <div id="text2" class="text-container">
      <p v-html="metaText.paragraph2" />
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="metaText.paragraph3" />
    </div>
    <div id="text4" class="text-container">
      <p v-html="metaText.paragraph4" />
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3';
import text from '../assets/text/text.js';

const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
const metaText = text.components.metaAnalysisText;
let textSize;

const dimensionColors = {
  Demographiccharacteristics: "#092836",
  Landtenure: "#1b695e",
  Livingconditions: "#7a5195",
  Socioeconomicstatus: "#2a468f",
  Health: "#ef5675",
  Riskperception: "#ff764a",
  Exposure: "#ffa600"
};

onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      transformData().then(result => {
        calculateTextSize();
        createDendrogram(result);
      }).catch(error => {
        console.error('Error transforming data:', error);
      });
    }
  });
});

async function loadData() {
  data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', d => {
    d.level_agreement = +d.level_agreement;
    d.evidence_val = +d.evidence_val;
    return d;
  });
}

function calculateTextSize() {
  textSize = mobileView ? '1.5em' : '.85em';
}

function transformData() {
  return new Promise((resolve) => {
    const nestedData = data.value.reduce((acc, item) => {
      let dimensionObj = acc.find(d => d.name === item.dimension);
      if (!dimensionObj) {
        dimensionObj = { name: item.dimension, children: [] };
        acc.push(dimensionObj);
      }
      let determinantObj = dimensionObj.children.find(d => d.name === item.determinant);
      if (!determinantObj) {
        determinantObj = { name: item.determinant, children: [] };
        dimensionObj.children.push(determinantObj);
      }
      determinantObj.children.push({
        name: item.indicator_wrapped,
        positively_related_total: item.positively_related_total,
        negatively_related_total: item.negatively_related_total,
        unrelated_total: item.unrelated_total,
        unknown_direction_total: item.unknown_direction_total,
        evidence_val: item.evidence_val,
        level_agreement: item.level_agreement
      });
      determinantObj.children.sort((a, b) => b.evidence_val - a.evidence_val);
      return acc;
    }, []);

    resolve({ name: 'root', children: nestedData });
  });
}

function createDendrogram(data) {
  const width = 1000;
  const margin = { top: 40, right: 40, bottom: 40, left: 40 };
  const dx = 35;
  const dy = width / 6;
  const root = d3.hierarchy(data);
  const tree = d3.tree().nodeSize([dx, dy]);

  root.x0 = dx / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);

  const svg = d3.select('#dendrogram-container')
    .append('svg')
    .attr('width', width + margin.right + margin.left)
    .attr('height', dx)
    .attr('viewBox', [-margin.left, -margin.top, width + margin.right, dx])
    .style('font', `${textSize} sans-serif`)
    .style('user-select', 'none');

  const gLink = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke-opacity', 0.8)
    .attr('stroke-width', 1.5);

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

  let i = 0;

  function update(source) {
    const nodes = root.descendants().reverse();
    const links = root.links();

    tree(root);

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + margin.top + margin.bottom;

    const transition = svg.transition()
      .duration(750)
      .attr('height', height)
      .attr('viewBox', [-margin.left, left.x - margin.top, width + margin.right, height]);

    const node = gNode.selectAll('g')
      .data(nodes, d => d.id || (d.id = ++i));

    const nodeEnter = node.enter().append('g')
      .attr('transform', d => `translate(${source.y0},${source.x0})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0)
      .on('click', (event, d) => {
        d.children = d.children ? null : d._children;
        update(d);
      });

    nodeEnter.append('circle')
      .attr('r', 2.5)
      .attr('fill', getNodeColor);

    nodeEnter.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => d._children ? -6 : 6)
      .attr('text-anchor', d => d._children ? 'end' : 'start')
      .text(d => d.data.name)
      .attr('fill', getNodeColor);

    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .attr('fill-opacity', 1)
      .attr('stroke-opacity', 1);

    const nodeExit = node.exit().transition(transition).remove()
      .attr('transform', d => `translate(${source.y},${source.x})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0);

    const link = gLink.selectAll('path')
      .data(links, d => d.target.id);

    const linkEnter = link.enter().append('path')
      .attr('d', d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .attr('stroke', getLinkColor);

    link.merge(linkEnter).transition(transition)
      .attr('d', diagonal)
      .attr('stroke', getLinkColor);

    link.exit().transition(transition).remove()
      .attr('d', d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });

    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

  update(root);
}

const colorScale = d3.scaleOrdinal()
  .domain(["Demographic characteristics", "Land tenure", "Living conditions", "Socioeconomic status", "Health", "Risk perception", "Exposure"])
  .range(Object.values(dimensionColors));

function getNodeColor(d) {
  if (d.depth === 1) return colorScale(d.data.name);
  if (d.parent && d.parent.depth === 1) return colorScale(d.parent.data.name);
  if (d.parent && d.parent.parent && d.parent.parent.depth === 1) return colorScale(d.parent.parent.data.name);
  return 'transparent';
}

function getLinkColor(d) {
  if (d.target.depth === 3) return colorScale(d.target.parent.parent.data.name);
  if (d.target.depth === 2) return colorScale(d.target.parent.data.name);
  if (d.target.depth === 1) return colorScale(d.target.data.name);
  return 'grey';
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}

#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  text-align: center;
}

#dendrogram-container svg {
  display: inline-block;
}
</style>
