<template>
  <section id="dendogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="metaText.title" />
    </div>
    <div id="text1" class="text-container">
      <p v-html="metaText.paragraph1" />
    </div>
    <div id="dendrogram-container"></div>
    <div id="text2" class="text-container">
      <p v-html="metaText.paragraph2" />
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="metaText.paragraph3" />
    </div>
    <div id="text4" class="text-container">
      <p v-html="metaText.paragraph4" />
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue'
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3'
import text from "../assets/text/text.js";

// global variables
const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
const metaText = text.components.metaAnalysisText;
let textSize;

// const width = 1000;
// const marginTop = 40;
// const marginRight = 100;
// const marginBottom = 10;
// const marginLeft = width / 7;

// set colors for lines
const dimensionColors = {
    Demographiccharacteristics: "#092836",
    Landtenure: "#1b695e",
    Livingconditions: "#7a5195",
    Socioeconomicstatus: "#2a468f",
    Health: "#ef5675",
    Riskperception: "#ff764a",
    Exposure: "#ffa600"
  };


// load data and then make chart
onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      transformData()
        .then((result) => {
          calculateTextSize();
          createDendrogram(result)
        })
        .catch((error) => {
          console.error('Error transforming data:', error)
        })
    }
  })
})

async function loadData() {
  // console.log(data);
  data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', (d) => {
    d.level_agreement = +d.level_agreement
    d.evidence_val = +d.evidence_val
    return d
  })
}

// check for mobile viewing and set appropriate text size
function calculateTextSize() {
  if (mobileView) {
    textSize = '1.5em';
    return textSize;
  } else {
    textSize = '.85em';
    return textSize;
  }
}

function transformData() {
  return new Promise((resolve, reject) => {
    const nestedData = data.value.reduce((acc, item) => {
      // check if dimension already exists in accumulator
      let dimensionObj = acc.find((d) => d.name === item.dimension)

      // if no dimension exists, create and add to acc
      if (!dimensionObj) {
        dimensionObj = {
          name: item.dimension,
          children: []
        }
        acc.push(dimensionObj)
      }

      // check if determinant already exists in dimension object
      let determinantObj = dimensionObj.children.find((d) => d.name === item.determinant)

      // iff not, create new determinant object and add to determinants array
      if (!determinantObj) {
        determinantObj = {
          name: item.determinant,
          children: []
        }
        dimensionObj.children.push(determinantObj)
      }

      // Add the current item to the indicators array
      determinantObj.children.push({
        name: item.indicator_wrapped,
        positively_related_total: item.positively_related_total,
        negatively_related_total: item.negatively_related_total,
        unrelated_total: item.unrelated_total,
        unknown_direction_total: item.unknown_direction_total,
        unknown_total: item.unknown_total,
        significant_total: item.significant_total,
        not_significant_total: item.not_significant_total,
        evidence_val: item.evidence_val,
        sig_name: item.sig_name,
        sig_value: item.sig_value,
        level_agreement: item.level_agreement
      })

      // Sort the children array of determinantObj based on evidence_val in descending order
      // we may not want this
      determinantObj.children.sort((a, b) => b.evidence_val - a.evidence_val)

      return acc
    }, [])

    const result = {
      name: ' ',
      children: nestedData
    }
    resolve(result)
  })
}

function createDendrogram(result) {
  // Specify the chart's dimensions. The height is variable, depending on the layout.
  const width = 1000;
  const marginTop = 40;
  const marginRight = 100;
  const marginBottom = 40;
  const marginLeft = width / 7;

  // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
  // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
  // "bottom", in the data domain. The width of a column is based on the tree's height.
  const root = d3.hierarchy(result)
  const dx = 35 
  const dy = (width - marginRight - marginLeft) / (1 + root.height)
  
  // Define the tree layout and the shape for links.
  const tree = d3.tree().nodeSize([dx, dy])
  if (mobileView){
    tree.separation(function(a,b) {
      if (a.parent === b.parent && (a.depth === 2 || a.depth ===3)){
        return 2
      } else {
        return 1
      }
    }
  )}

  const diagonal = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);

  // Create the SVG container, a layer for the links and a layer for the nodes.
  const svg = d3
    .select('#dendrogram-container')
    .append('svg')
    .attr('width', width)
    .attr('height', dx)
    .attr('viewBox', [-marginLeft, -marginTop, width, dx])
    .attr(
      'style',
      "max-width: 100%; height: auto; font-size: " +
      textSize +
      "; font-weight: 600; user-select: none;"
    )

  const gLink = svg
    .append('g')
    .attr('fill', 'none')
    .attr('stroke', '#555')
    .attr('stroke-opacity', 0.4)
    .attr('stroke-width', 1.5)

  const gNode = svg
    .append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

  function update(event, source) {
    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
    const nodes = root.descendants().reverse();
    const links = root.links().filter(link => link.source.depth !== 0); // Exclude the root node from all links

    // Compute the new tree layout.
    tree(root)

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + marginTop + marginBottom;

    const transition = svg.transition()
      .duration(duration)
      .attr("height", height)
      .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
      .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

    // Update the nodes…
    const node = gNode.selectAll("g")
      .data(nodes, d => d.id);

    // Enter any new nodes at the parent's previous position.
    const nodeEnter = node.enter().append("g")
      .attr("transform", d => `translate(${source.y0},${source.x0})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0)
      .on("click", (event, d) => {
        d.children = d.children ? null : d._children;
        update(event, d);
      });

    nodeEnter.append("circle")
      .attr("r", 2.5)
      .attr("fill", getNodeColor)
      .attr("stroke-width", 10);

    // set text wrap width depending on mobile view
    const wrapWidth = mobileView ? 100 : 175;

    const textElements = nodeEnter.append("text")
      .attr("dy", "0.31em")
      .attr("x", d => d._children ? -6 : 6)
      .attr("text-anchor", d => d._children ? "end" : "start")
      .text(d => d.data.name)
      .style("fill", getNodeColor)
      
    textElements.filter(d => d.depth === 1) 
      .clone(true).lower()
      .attr("stroke-linejoin", "round")
      .attr("stroke-width", 3)
      .attr("stroke", "white")
    
    textElements.filter(d => d.depth === 2 || d.depth === 3)
      .call(wrap, wrapWidth)
      .clone(true).lower()
      .attr("stroke-linejoin", "round")
      .attr("stroke-width", 3)
      .attr("stroke", "white")

    // Transition nodes to their new position.
    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr("transform", d => `translate(${d.y},${d.x})`)
      .attr("fill-opacity", 1)
      .attr("stroke-opacity", 1);

    // Transition exiting nodes to the parent's new position.
    const nodeExit = node.exit().transition(transition).remove()
      .attr("transform", d => `translate(${source.y},${source.x})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0);

    // Update the links…
    const link = gLink.selectAll("path")
      .data(links, d => d.target.id);

    // Enter any new links at the parent's previous position.
    const linkEnter = link.enter().append("path")
      .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .attr("stroke-width", getLinkWidth)
      .attr("stroke", getLinkColor);

    // Transition links to their new position.
    link.merge(linkEnter).transition(transition)
      .attr("d", diagonal)
      .attr("stroke-width", getLinkWidth)
      .attr("stroke", getLinkColor);

    // Transition exiting nodes to the parent's new position.
    link.exit().transition(transition).remove()
      .attr("d", d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });


    // Stash the old positions for transition.
    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  // Do the first update to the initial configuration of the tree — where only the root node is open.
  root.x0 = ((width - marginRight - marginLeft) / (1 + root.height)) / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth !== 0) {
      d.children = null; // Set children to null for all nodes except the root
    }
  });
  update(null, root);

  return svg.node();
}

  // function to wrap text
  function wrap(text, width) {
    // console.log(isMobile);
    text.each(function() { 
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1, // Adjust this value as needed
            x = text.attr("x"),
            y = text.attr("y"),
            dy = 0,
            tspan = text.text(null)
                .append("tspan")
                .attr("x", x)
                .attr("y", y)
                .attr("dy", dy + "em");
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
              line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", ++lineNumber * lineHeight + dy + "em")
                    .text(word);
            }
        }
        var totalHeight = lineNumber * lineHeight;
        if (totalHeight > 0) {
          text.attr("y", y - totalHeight / 2);
        } else {
          text.attr("y", y +5)
        }
    });
  }

  // Define a color scale for the nodes based on category names and depth
  const colorScale = d3.scaleOrdinal()
    .domain(["Demographic characteristics", "Land tenure", "Living conditions", "Socioeconomic status", "Health", "Risk perception", "Exposure"])
    .range(Object.entries(dimensionColors).map(([key, value]) => value));

    // Function to determine the color of a node based on its category
  function getNodeColor(d) {
    // If the node is one of the main categories, return its color
    // console.log(d.data.name);
    if (d.depth === 1) {
      return colorScale(d.data.name);
    }
    // If the node is a child of a main category, return the color of its parent
    else if (d.parent && d.parent.depth === 1) {
      return colorScale(d.parent.data.name);
    }
    // If the node is a grandchild or further, return the color of its grandparent
    else if (d.parent && d.parent.parent && d.parent.parent.depth === 1) {
      return colorScale(d.parent.parent.data.name);
    }
    // If none of the above conditions are met, fallback to a default color
    else {
      return "transparent"; // You can choose any default color here
    }
  }

// Function to determine the color of a link based on its target node's depth
function getLinkColor(d) {
  // If the target node is a great-grandchild (depth 3), return the color of its grandparent
  if (d.target.depth === 3) {
    return colorScale(d.target.parent.parent.data.name);
  }
  // If the target node is a grandchild (depth 2), return the color of its parent
  else if (d.target.depth === 2) {
    return colorScale(d.target.parent.data.name);
  }
  // If the target node is a child of a main category (depth 1), return the color of the target node
  else if (d.target.depth === 1) {
    return colorScale(d.target.data.name);
  }
  // If none of the above conditions are met, fallback to a default color
  else {
    return "red"; // You can choose any default color here
  }
}

function getLinkWidth(d) {
  // If the target node is a great-grandchild (depth 3), return the great-grandchild's evidence_val
  if (d.target.depth === 3) {
    return d.target.data.evidence_val;
  }
  // If the target node is a grandchild (depth 2), return the sum of the great-grandchildren's evidence_val
  else if (d.target.depth === 2) {
    return d.target.data.children ? d.target.data.children.reduce((acc, child) => { return acc + child.evidence_val }, 0) : 1.5;
  }
  // If the target node is a child of a main category (depth 1), return the sum of the grandchildren's evidence_val
  else if (d.target.depth === 1) {
    return d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + (child.children ? child.children.reduce((acc, grandchild) => acc + grandchild.evidence_val, 0) : 0), 0): 1.5;
  }
  // If none of the above conditions are met, return a default width
  else {
    return 1.5; // You can choose any default width here
  }
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}
#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  // max-height: 70vh;
  text-align: center;
  // position: relative;
}

#dendrogram-container svg {
  // max-width: 100%;
  // max-height: 100%;
  // height: auto; /* Maintain aspect ratio */
  display: inline-block;
}
</style>
