<template>
  <section id="dendogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="metaText.title"></h3>
    </div>
    <div id="text1" class="text-container">
      <p v-html="metaText.paragraph1"></p>
    </div>
    <div id="text2" class="text-container tooltip-width">
      <em>Click on the diagram to see the different vulnerability indicators studied in relation to water insecurity. The edges of the diagram are thicker for more well studied topics.</em>
    </div>
    <div id="dendrogram-container"></div>
    <div id="text2" class="text-container">
      <p v-html="metaText.paragraph2"></p>
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="metaText.paragraph3"></p>
    </div>
    <div id="text4" class="text-container">
      <p v-html="metaText.paragraph4"></p>
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3';
import text from "../assets/text/text.js";

// global variables
const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
const metaText = text.components.metaAnalysisText;
let textSize;

// set colors for dimension
const dimensionColors = {
  Demographiccharacteristics: "#092836",
  Landtenure: "#1b695e",
  Livingconditions: "#7a5195",
  Socioeconomicstatus: "#2a468f",
  Health: "#ef5675",
  Riskperception: "#ff764a",
  Exposure: "#ffa600"
};

// Define scales for link width and node radius
let linkWidthScale, nodeRadiusScale;

onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      linkWidthScale = d3.scaleLinear()
        .domain([0, d3.max(data.value, d => d.evidence_val)])
        .range([1, 14]);

      nodeRadiusScale = d3.scaleLinear()
        .domain([0, d3.max(data.value, d => d.evidence_val)])
        .range([1, 7]); 

      transformData()
        .then((result) => {
          calculateTextSize();
          createDendrogram(result);
        })
        .catch((error) => {
          console.error('Error transforming data:', error);
        });
    }
  });
})

async function loadData() {
  data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', (d) => {
    d.level_agreement = +d.level_agreement
    d.evidence_val = +d.evidence_val
    return d
  });
}

function calculateTextSize() {
  if (mobileView) {
    textSize = '1.5em';
  } else {
    textSize = '.85em';
  }
}

function transformData() {
  return new Promise((resolve, reject) => {
    const nestedData = data.value.reduce((acc, item) => {
      let dimensionObj = acc.find((d) => d.name === item.dimension)
      if (!dimensionObj) {
        dimensionObj = { name: item.dimension, children: [], totalEvidence: 0 }
        acc.push(dimensionObj)
      }

      let determinantObj = dimensionObj.children.find((d) => d.name === item.determinant)
      if (!determinantObj) {
        determinantObj = { name: item.determinant, children: [], totalEvidence: 0 }
        dimensionObj.children.push(determinantObj)
      }

      determinantObj.children.push({
        name: item.indicator_wrapped,
        evidence_val: item.evidence_val,
        level_agreement: item.level_agreement
      })

      return acc;
    }, [])

    // Calculate total evidence for each level
    const calculateTotalEvidence = (node) => {
      if (node.children) {
        node.totalEvidence = node.children.reduce((acc, child) => acc + calculateTotalEvidence(child), 0);
      } else {
        node.totalEvidence = node.evidence_val || 0;
      }
      return node.totalEvidence;
    };

    nestedData.forEach(dimension => calculateTotalEvidence(dimension));

    const result = { name: ' ', children: nestedData }
    resolve(result)
  })
}

function createDendrogram(result) {
  const width = 1000;
  const marginTop = 40;
  const marginRight = 100;
  const marginBottom = 40;
  const marginLeft = width / 7;

  const root = d3.hierarchy(result);
  const dx = 10; // Further decreased vertical spacing
  const dy = (width - marginRight - marginLeft) / (1 + root.height);

  const tree = d3.tree().nodeSize([dx, dy]);

  // Expand level 2 nodes
  root.descendants().forEach(d => {
    if (d.depth === 1) {
      d.children = d._children || d.children;
    }
  });

  // Use separation to ensure consistent spacing between nodes
  tree.separation((a, b) => (a.parent === b.parent ? 1 : 2) + (a.data.name.split(/\s+/).length + b.data.name.split(/\s+/).length) / 2);

  const diagonal = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);

  const svg = d3.select('#dendrogram-container')
    .append('svg')
    .attr('width', width)
    .attr('viewBox', [-marginLeft, -marginTop, width, dx * (root.height + 1)])
    .style('max-width', '100%')
    .style('height', 'auto')
    .style('font-size', textSize)
    .style('font-weight', 600)
    .style('user-select', 'none');

  const gLink = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke', '#555')
    .attr('stroke-opacity', 0.9);

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

  function update(event, source) {
    const duration = 1200;
    const nodes = root.descendants().reverse();
    const links = root.links().filter(link => link.source.depth !== 0);

    // Calculate the number of lines for each level 3 text label
    nodes.forEach(d => {
      if (d.depth === 3) {
        const words = d.data.name.split(/\s+/);
        const wrapWidth = mobileView ? 100 : 175;
        const testLine = [];
        let lineNumber = 0;
        words.forEach(word => {
          testLine.push(word);
          const testSpan = document.createElement('span');
          testSpan.style.visibility = 'hidden';
          testSpan.style.position = 'absolute';
          testSpan.style.width = `${wrapWidth}px`;
          testSpan.textContent = testLine.join(' ');
          document.body.appendChild(testSpan);
          if (testSpan.offsetWidth > wrapWidth) {
            testLine.pop();
            testSpan.textContent = testLine.join(' ');
            lineNumber++;
            testLine.length = 0;
            testLine.push(word);
          }
          document.body.removeChild(testSpan);
        });
        lineNumber++; // for the last line
        d.lines = lineNumber;
      } else {
        d.lines = 1;
      }
    });

    // Update the tree layout with the adjusted vertical spacing
    tree.nodeSize([dx * nodes[0].lines, dy]);

    tree(root);

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + marginTop + marginBottom;

    const transition = svg.transition()
      .duration(duration)
      .attr('height', height)
      .attr('viewBox', [-marginLeft, left.x - marginTop, width, height])
      .tween('resize', window.ResizeObserver ? null : () => () => svg.dispatch('toggle'));

    const node = gNode.selectAll('g')
      .data(nodes, d => d.id);

    const nodeEnter = node.enter().append('g')
      .attr('transform', d => `translate(${source.y0},${source.x0})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0)
      .on('click', (event, d) => {
        d.children = d.children ? null : d._children;
        update(event, d);
      });

    nodeEnter.append('circle')
      .attr('r', d => getNodeRadius(d))
      .attr('fill', getNodeColor)
      .attr('stroke-width', 10);

    const wrapWidth = mobileView ? 100 : 175;

    const textElements = nodeEnter.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => {
        if (d.depth === 1) {
          return -getNodeRadius(d) - 6;
        } else {
          return getNodeRadius(d) + 6; // Position text on the right of node for level 2 and 3
        }
      })
      .attr('text-anchor', d => d.depth === 1 ? 'end' : 'start')
      .text(d => d.data.name)
      .style('fill', getNodeColor);

    textElements.filter(d => d.depth === 1)
      .clone(true).lower()
      .attr('stroke-linejoin', 'round')
      .attr('stroke-width', 3)
      .attr('stroke', 'white');

    textElements.filter(d => d.depth === 3)
      .call(wrap, wrapWidth)
      .clone(true).lower()
      .attr('stroke-linejoin', 'round')
      .attr('stroke-width', 3)
      .attr('stroke', 'white');

    // Hide second-level labels if third-level children are visible
    node.selectAll('text')
      .filter(d => d.depth === 2)
      .style('display', d => (d.children && d.children.length > 0) ? 'none' : 'inline');

    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .attr('fill-opacity', 1)
      .attr('stroke-opacity', 1);

    const nodeExit = node.exit().transition(transition).remove()
      .attr('transform', d => `translate(${source.y},${source.x})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0);

    const link = gLink.selectAll('path')
      .data(links, d => d.target.id);

    const linkEnter = link.enter().append('path')
      .attr('d', d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .attr('stroke-width', getLinkWidth)
      .attr('stroke', getLinkColor);

    link.merge(linkEnter).transition(transition)
      .attr('d', diagonal)
      .attr('stroke-width', getLinkWidth)
      .attr('stroke', getLinkColor);

    link.exit().transition(transition).remove()
      .attr('d', d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });

    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  root.x0 = ((width - marginRight - marginLeft) / (1 + root.height)) / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth !== 0) {
      d.children = null;
    }
  });
  update(null, root);
  return svg.node();
}

function wrap(text, width) {
  text.each(function() { 
    let text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.1, // Consistent line height
        x = text.attr('x'),
        y = text.attr('y'),
        dy = parseFloat(text.attr('dy')),
        tspan = text.text(null).append('tspan').attr('x', x).attr('dy', dy + 'em');
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(' '));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(' '));
        line = [word];
        tspan = text.append('tspan').attr('x', x).attr('dy', lineHeight + 'em').text(word);
      }
    }
  });
}

const colorScale = d3.scaleOrdinal()
  .domain(["Demographic characteristics", "Land tenure", "Living conditions", "Socioeconomic status", "Health", "Risk perception", "Exposure"])
  .range(Object.entries(dimensionColors).map(([key, value]) => value));

function getNodeColor(d) {
  if (d.depth === 1) {
    return colorScale(d.data.name);
  } else if (d.parent && d.parent.depth === 1) {
    return colorScale(d.parent.data.name);
  } else if (d.parent && d.parent.parent && d.parent.parent.depth === 1) {
    return colorScale(d.parent.parent.data.name);
  } else {
    return 'transparent';
  }
}

function getLinkColor(d) {
  if (d.target.depth === 3) {
    return colorScale(d.target.parent.parent.data.name);
  } else if (d.target.depth === 2) {
    return colorScale(d.target.parent.data.name);
  } else if (d.target.depth === 1) {
    return colorScale(d.target.data.name);
  } else {
    return 'red';
  }
}

function getLinkWidth(d) {
  if (d.target.depth === 3) {
    return linkWidthScale(d.target.data.evidence_val);
  } else if (d.target.depth === 2) {
    return linkWidthScale(d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + child.evidence_val, 0) : 1.5);
  } else if (d.target.depth === 1) {
    return linkWidthScale(d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + (child.children ? child.children.reduce((acc, grandchild) => acc + grandchild.evidence_val, 0) : 0), 0) : 1.5);
  } else {
    return 1.5;
  }
}

function getNodeRadius(d) {
  if (d.depth === 3) {
    return nodeRadiusScale(d.data.evidence_val);
  } else if (d.depth === 2) {
    let totalEvidence = d.data.totalEvidence;
    return nodeRadiusScale(totalEvidence);
  } else if (d.depth === 1) {
    return 0; // Hide circles for level 1 nodes
  } else {
    return 2.5;
  }
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}
#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  text-align: center;
}

#dendrogram-container svg {
  display: inline-block;
}
</style>
