<template>
  <section id="dendrogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="t('text.components.metaAnalysisText.title')"></h3>
    </div>
    <div id="text1" class="text-container">
      <p v-html="t('text.components.metaAnalysisText.paragraph1')"></p>
    </div>
    <div id="image-container">
  <figure>
    <figcaption>
    <em><p v-html="t('text.components.chartText.dendroExplainer')"></p></em> 
    </figcaption>
    <img src="@/assets/images/alphanumeric.png" alt="Image showing how to interact with a dendrogram chart that is below of social vulnerability dimensions, determinants, and indicators. A cursor is clicking the node of the dendrogram showing the leaves can be expanded to see the various levels of social indicators studied.">
  </figure>
</div>
    <div id="dendrogram-container" 
    aria-label="Dendrogram showing nested hierarchy of vulnerability indicators related to water insecurity. Indicators fall within one of 6 dimensions: demographic characteristics, exposure to stressors, health, land tenure, living conditions, risk perception, and socioeconomic status. Within the dimensions there were 50 determinants that individual indicators, or data variables fit within. The most well studied were demographic characteristics of ethnicity and race and related to age. Similarly, socioeconomic variables related to income, wealth, and education were relatively well studied. Exposure to various physical conditions were also well studied. To access the data, including the number of studies for each indicator and their relationship with vulnerability, go to the csv  provided:  https://www.sciencebase.gov/catalog/item/63f79d49d34e4f7eda456572"></div>
    <div id="text2" class="text-container">
      <p v-html="t('text.components.metaAnalysisText.paragraph2')"></p>
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="t('text.components.metaAnalysisText.paragraph3')"></p>
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3';
import { useI18n } from 'vue-i18n';

const { t } = useI18n();

// global variables
const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
let textSize;

// set colors for dimension
const dimensionColors = {
  "demographiccharacteristics": "#092836",
  "landtenure": "#1b695e",
  "livingconditions": "#7a5195",
  "socioeconomicstatus": "#2a468f",
  "health": "#ef5675",
  "riskperception": "#ff764a",
  "exposure": "#ffa600"
};

const dimensionColors_es = {
  "lascaracterísticasdemográficas": "#092836",
  "latenenciadelatierra": "#1b695e",
  "lascondicionesdevida": "#7a5195",
  "elestatussocioeconómico": "#2a468f",
  "lasalud": "#ef5675",
  "lapercepcióndelriesgo": "#ff764a",
  "laexposiciónafuentesdeestrés": "#ffa600"
};

// Define scales for link width and node radius
let linkWidthScale, nodeRadiusScale;

onMounted(() => {
  const userLang = navigator.language || navigator.userLanguage;
  const isSpanish = userLang.startsWith('es'); // Check if the language is Spanish

  loadData().then(() => {
    if (data.value.length > 0) {
      linkWidthScale = d3.scaleLinear()
        .domain([0, d3.max(data.value, d => d.evidence_val)])
        .range([1, 14]);

      nodeRadiusScale = d3.scaleLinear()
        .domain([0, d3.max(data.value, d => d.evidence_val)])
        .range([2, 9]);

      transformData(isSpanish)
        .then((result) => {
          calculateTextSize();
          createDendrogram(result, isSpanish);
        })
        .catch((error) => {
          console.error('Error transforming data:', error);
        });
    }
  });
})

async function loadData(isSpanish) {
  try {
    const jsonData = await d3.json(publicPath + 'indicator_uncertainty.json');
    data.value = jsonData.map((d) => {
      d.level_agreement = +d.level_agreement;
      d.evidence_val = +d.evidence_val;
      return d;
    });
  } catch (error) {
    console.error('Error loading JSON data:', error);
  }
}

function calculateTextSize() {
  if (mobileView) {
    textSize = '1.5em';
  } else {
    textSize = '0.9em';
  }
}

function transformData(isSpanish) {
  return new Promise((resolve) => {
    const nestedData = data.value.reduce((acc, item) => {
      const dimensionName = isSpanish ? item.dimension_es : item.dimension;
      let dimensionObj = acc.find((d) => d.name === dimensionName);
      if (!dimensionObj) {
        dimensionObj = { name: dimensionName, children: [], totalEvidence: 0 };
        acc.push(dimensionObj);
      }

      const determinantName = isSpanish ? item.determinant_es : item.determinant_wrapped;
      let determinantObj = dimensionObj.children.find((d) => d.name === determinantName);
      if (!determinantObj) {
        determinantObj = { name: determinantName, children: [], totalEvidence: 0 };
        dimensionObj.children.push(determinantObj);
      }

      const indicatorName = isSpanish ? item.indicator_es : item.indicator_wrapped;
      determinantObj.children.push({
        name: indicatorName,
        evidence_val: item.evidence_val,
        level_agreement: item.level_agreement
      });

      return acc;
    }, []);

    // Calculate total evidence for each level
    const calculateTotalEvidence = (node) => {
      if (node.children) {
        node.totalEvidence = node.children.reduce((acc, child) => acc + calculateTotalEvidence(child), 0);
      } else {
        node.totalEvidence = node.evidence_val || 0;
      }
      return node.totalEvidence;
    };

    nestedData.forEach(dimension => calculateTotalEvidence(dimension));

    const result = { name: ' ', children: nestedData };
    resolve(result);
  });
}



function createDendrogram(result, isSpanish) {
  const width = 1000;
  const height = 800;
  const marginTop = 40;
  const marginRight = 100;
  const marginBottom = 40;
  const marginLeft = 0;

  const root = d3.hierarchy(result);
  const dx = mobileView ? 15 : 10;  // Increase dx for mobile
  const dy = (width - marginRight - marginLeft) / (1 + root.height);


  const tree = d3.tree().nodeSize([dx, dy]);

// Position nodes based on depth
root.descendants().forEach(d => {
  if (mobileView) {
    if (d.depth === 1) {
      d.y = d.depth * (width * 0.1);
    } else if (d.depth === 2) {
      d.y = d.depth * (width * 0.1);
    } else if (d.depth === 3) {
      d.y = d.depth * (width * 0.4) + (d.index * 20); // Add extra spacing for depth 3
    } else {
      d.y = d.depth * (width * 0.4);
    }
  } else {
    d.y = d.depth * (width * 0.25);
  }
});

  tree.separation((a, b) => (a.parent === b.parent ? 1 : 2) + (a.data.name.split(/\s+/).length + b.data.name.split(/\s+/).length) / 2);

  const diagonal = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);

  const svg = d3.select('#dendrogram-container')
    .append('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('viewBox', [0, -marginTop, width, height])
    .style('max-width', '100%')
    .style('height', 'auto')
    .style('font-size', textSize)
    .style('font-weight', 600)
    .style('user-select', 'none')
    .attr('aria-hidden', 'true');

  const gLink = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke', '#555')
    .attr('stroke-opacity', 0.9);

  const gNodeBg = svg.append('g');

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

    function update(event, source) {
  const duration = 1200;
  const nodes = root.descendants().reverse();
  const links = root.links().filter(link => link.source.depth !== 0);

  // Calculate text sizes for wrapping
  nodes.forEach(d => {
    if (d.depth === 3) {
      const words = d.data.name.split(/\s+/);
      const wrapWidth = mobileView ? 300 : 300;
      const testLine = [];
      let lineNumber = 0;
      words.forEach(word => {
        testLine.push(word);
        const testSpan = document.createElement('span');
        testSpan.style.visibility = 'hidden';
        testSpan.style.position = 'absolute';
        testSpan.style.width = `${wrapWidth}px`;
        testSpan.textContent = testLine.join(' ');
        document.body.appendChild(testSpan);
        if (testSpan.offsetWidth > wrapWidth) {
          testLine.pop();
          testSpan.textContent = testLine.join(' ');
          lineNumber++;
          testLine.length = 0;
          testLine.push(word);
        }
        document.body.removeChild(testSpan);
      });
      lineNumber++;
      d.lines = lineNumber;
    } else {
      d.lines = 1;
    }
  });

  tree.nodeSize([dx * nodes[0].lines, dy]);

  tree(root);

  let left = root;
  let right = root;
  root.eachBefore(node => {
    if (node.x < left.x) left = node;
    if (node.x > right.x) right = node;
  });

  const height = right.x - left.x + marginTop + marginBottom;

  const transition = svg.transition()
    .duration(duration)
    .attr('height', height)
    .attr('viewBox', [0, left.x - marginTop, width, height])
    .tween('resize', window.ResizeObserver ? null : () => () => svg.dispatch('toggle'));

  // Update nodes and links
  const node = gNode.selectAll('g.node')
    .data(nodes, d => d.id);

  const nodeBg = gNodeBg.selectAll('g.node-bg')
    .data(nodes, d => d.id);

  // Enter new nodes
  const nodeBgEnter = nodeBg.enter().append('g')
    .attr('class', 'node-bg')
    .attr('transform', d => `translate(${source.y0},${source.x0})`)
    .attr('fill-opacity', "white")
    .attr('stroke-opacity', 0)
    .attr('stroke-width', 2);

  nodeBgEnter.append('circle')
  .attr('r', d => (d.depth !== 1 ? getNodeRadius(d) + 4 : 0))
    .attr('fill', "white");

  const nodeEnter = node.enter().append('g')
    .attr('class', 'node')
    .attr('transform', `translate(${source.y0},${source.x0})`)
    .attr('fill-opacity', 0)
    .attr('stroke-opacity', 0)
    .on('click', (event, d) => {
      // Disable interaction for depth 1 and 3 nodes
      if (d.depth !== 1 && d.depth !== 3) {
        d.children = d.children ? null : d._children;
        update(event, d);
      }
    });

  nodeEnter.append('circle')
    .filter(d => d.depth !== 1)
    .attr('r', d => getNodeRadius(d))
    .attr('fill', d =>  getNodeColor(d, isSpanish))
    .attr('stroke', d => getNodeColor(d, isSpanish))
    .attr('stroke-width', 2);

  const wrapWidth = mobileView ? 300 : 300;

  const textElements = nodeEnter.append('text')
    .attr('dy', '0.31em')
    .attr('x', d => {
      if (d.depth === 1) {
        return -getNodeRadius(d) - 6;
      } else {
        return getNodeRadius(d) + 6;
      }
    })
    .attr('text-anchor', d => d.depth === 1 ? 'end' : 'start')
    .text(d => d.depth === 3 ? `${d.data.name} (${d.data.evidence_val})` : d.data.name)
    .style('fill', d => getNodeColor(d, isSpanish));

    function wrapAfterSecondWord(textSelection, isSpanish) {
      textSelection.each(function() {
        const textElement = d3.select(this);
        const text = textElement.text();  // Get the original text

        // Split the text into words
        const words = text.split(/\s+/);

        // For English: Break after 1st word, for Spanish: Break after 2nd word
        const breakAfter = isSpanish ? 2 : 1;

        // If there are more than 2 words, wrap after the second word
        if (words.length > breakAfter) {
          textElement.text(null);  // Clear the current text

          // Append the first two words in one line
          textElement.append('tspan')
            .attr('x', -10)
            .attr('dy', '0em')
            .text(words.slice(0, breakAfter).join(' '));

          // Append the remaining words in the next line
          textElement.append('tspan')
            .attr('x', -10)
            .attr('dy', '1.2em')
            .text(words.slice(breakAfter).join(' '));
        }
    });
  }

  textElements.filter(d => d.depth === 1)
  .call(wrapAfterSecondWord, isSpanish)
    .clone(true).lower()
    .attr('stroke-linejoin', 'round')
    .attr('stroke-width', 3)
    .attr('stroke', 'white');

  textElements.filter(d => d.depth === 3)
    .call(wrap, wrapWidth)
    .clone(true).lower()
    .attr('stroke-linejoin', 'round')
    .attr('stroke-width', 3)
    .attr('stroke', 'white');

  node.selectAll('text')
    .filter(d => d.depth === 2)
    .style('display', d => (d.children && d.children.length > 0) ? 'none' : 'inline');

  // Merge and update node backgrounds
  const nodeBgUpdate = nodeBg.merge(nodeBgEnter).transition(transition)
    .attr('transform', d => `translate(${d.y},${d.x})`)
    .attr('fill-opacity', 1)
    .attr('stroke-opacity', 1);

  const nodeBgExit = nodeBg.exit().transition(transition).remove()
    .attr('transform', d => `translate(${source.y},${source.x})`)
    .attr('fill-opacity', 0)
    .attr('stroke-opacity', 0);

  // Merge and update nodes
  const nodeUpdate = node.merge(nodeEnter).transition(transition)
    .attr('transform', d => `translate(${d.y},${d.x})`)
    .attr('fill-opacity', 1)
    .attr('stroke-opacity', 1);

  node.exit().transition(transition).remove()
    .attr('transform', `translate(${source.y},${source.x})`)
    .attr('fill-opacity', 0)
    .attr('stroke-opacity', 0);

  // Update links
  const link = gLink.selectAll('path')
    .data(links, d => d.target.id);

  const linkEnter = link.enter().append('path')
    .attr('d', () => {
      const o = { x: source.x0, y: source.y0 };
      return diagonal({ source: o, target: o });
    })
    .attr('stroke-width', getLinkWidth)
    .attr('stroke',  d => getLinkColor(d, isSpanish));

  link.merge(linkEnter).transition(transition)
    .attr('d', diagonal)
    .attr('stroke-width', getLinkWidth)
    .attr('stroke', d => getLinkColor(d, isSpanish));

  link.exit().transition(transition).remove()
    .attr('d', () => {
      const o = { x: source.x, y: source.y };
      return diagonal({ source: o, target: o });
    });

  root.eachBefore(d => {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}
  root.x0 = ((width - marginRight - marginLeft) / (1 + root.height)) / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth === 2) {
      d.children = null;
    }
  });
  update(null, root);
  return svg.node();
}
function normalizeDimensionName(name) {
  return name.trim().replace(/\s+/g, '').toLowerCase();  // Remove spaces and convert to lowercase
}


function wrap(text, width) {
  text.each(function() {
    const textElement = d3.select(this);
    let words = textElement.text().normalize('NFKD')  // Normalize the text
      .replace(/[^\w\s]/g, '')  // Remove any special characters if needed
      .split(/\s+/)  // Split by spaces
      .reverse();  // Reverse the order

    let word,
      line = [],
      lineNumber = 0,
      lineHeight = 1.1,  // Consistent line height
      x = textElement.attr('x'),
      dy = parseFloat(textElement.attr('dy')),
      tspan = textElement.text(null).append('tspan').attr('x', x).attr('dy', dy + 'em');

    while ((word = words.pop())) {
      line.push(word);
      tspan.text(line.join(' '));

      // If the width exceeds the max allowed, break the line
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();  // Remove the last word
        tspan.text(line.join(' '));  // Reset the text for the current line
        line = [word];  // Start a new line
        tspan = textElement.append('tspan').attr('x', x).attr('dy', lineHeight + 'em').text(word);
      }
    }
  });
}


const colorScale = d3.scaleOrdinal()
  .domain(["Demographic characteristics", "Land tenure", "Living conditions", "Socioeconomic status", "Health", "Risk perception", "Exposure"])
  .range(Object.values(dimensionColors));
  
  function getNodeColor(d, isSpanish) {
  // Choose the correct color map based on the language
  const colorMap = isSpanish ? dimensionColors_es : dimensionColors;
  
  if (d.depth === 1) {
    const normalizedDimension = normalizeDimensionName(d.data.name);
    return colorMap[normalizedDimension] || '#ccc';  // Fallback to grey if not found
  } else if (d.parent && d.parent.depth === 1) {
    const normalizedDimension = normalizeDimensionName(d.parent.data.name);
    return colorMap[normalizedDimension] || '#ccc';
  } else if (d.parent && d.parent.parent && d.parent.parent.depth === 1) {
    const normalizedDimension = normalizeDimensionName(d.parent.parent.data.name);
    return colorMap[normalizedDimension] || '#ccc';
  } else {
    return '#ccc';  // Fallback color
  }
}

function getLinkColor(d, isSpanish) {
  const colorMap = isSpanish ? dimensionColors_es : dimensionColors;

  if (d.target.depth === 3) {
    const normalizedDimension = normalizeDimensionName(d.target.parent.parent.data.name);
    return colorMap[normalizedDimension] || '#ccc';
  } else if (d.target.depth === 2) {
    const normalizedDimension = normalizeDimensionName(d.target.parent.data.name);
    return colorMap[normalizedDimension] || '#ccc';
  } else if (d.target.depth === 1) {
    const normalizedDimension = normalizeDimensionName(d.target.data.name);
    return colorMap[normalizedDimension] || '#ccc';
  } else {
    return 'red';  // Fallback color for other cases
  }
}



function getLinkWidth(d) {
  if (d.target.depth === 3) {
    return linkWidthScale(d.target.data.evidence_val);
  } else if (d.target.depth === 2) {
    return linkWidthScale(d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + child.evidence_val, 0) : 1.5);
  } else if (d.target.depth === 1) {
    return linkWidthScale(d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + (child.children ? child.children.reduce((acc, grandchild) => acc + grandchild.evidence_val, 0) : 0), 0) : 1.5);
  } else {
    return 1.5;
  }
}

function getNodeRadius(d) {
  if (d.depth === 3) {
    return nodeRadiusScale(d.data.evidence_val);
  } else if (d.depth === 2) {
    let totalEvidence = d.data.totalEvidence;
    return nodeRadiusScale(totalEvidence);
  } else if (d.depth === 1) {
    return 0; // Hide circles for level 1 nodes
  } else {
    return 2.5;
  }
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}
#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  text-align: center;
}

#dendrogram-container svg {
  display: inline-block;
}

#image-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 2rem auto 2rem auto;
  padding: 2rem 2rem 2rem 2rem;
  background-color: rgba(242, 242, 242, 0.95); 
  border-radius: 10px; 
  display: flex; 
  justify-content: center; 
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

#image-container figcaption {
  text-align: center; /* Center the text */
  margin-bottom: 1rem; /* Space between caption and image */
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}
</style>
