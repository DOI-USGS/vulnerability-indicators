<template>
  <section id="dendogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="metaText.title"></h3>
    </div>
    <div id="text1" class="text-container">
      <p v-html="metaText.paragraph1"></p>
    </div>
    <div id="dendrogram-container"></div>
    <div id="text2" class="text-container">
      <p v-html="metaText.paragraph2"></p>
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="metaText.paragraph3"></p>
    </div>
    <div id="text4" class="text-container">
      <p v-html="metaText.paragraph4"></p>
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3';
import text from "../assets/text/text.js";

// global variables
const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
const metaText = text.components.metaAnalysisText;
let textSize;

// set colors for dimension
const dimensionColors = {
  Demographiccharacteristics: "#092836",
  Landtenure: "#1b695e",
  Livingconditions: "#7a5195",
  Socioeconomicstatus: "#2a468f",
  Health: "#ef5675",
  Riskperception: "#ff764a",
  Exposure: "#ffa600"
};

// Define scales for link width and node radius
let linkWidthScale, nodeRadiusScale;

onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      linkWidthScale = d3.scaleLinear()
        .domain([0, d3.max(data.value, d => d.evidence_val)])
        .range([0.5, 14]);

      nodeRadiusScale = d3.scaleLinear()
        .domain([0, d3.max(data.value, d => d.evidence_val)])
        .range([2.5, 10]); 

      transformData()
        .then((result) => {
          calculateTextSize();
          createDendrogram(result);
        })
        .catch((error) => {
          console.error('Error transforming data:', error);
        });
    }
  });
})

async function loadData() {
  data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', (d) => {
    d.level_agreement = +d.level_agreement
    d.evidence_val = +d.evidence_val
    return d
  });
}

function calculateTextSize() {
  if (mobileView) {
    textSize = '1.5em';
  } else {
    textSize = '.85em';
  }
}

function transformData() {
  return new Promise((resolve, reject) => {
    const nestedData = data.value.reduce((acc, item) => {
      let dimensionObj = acc.find((d) => d.name === item.dimension)
      if (!dimensionObj) {
        dimensionObj = { name: item.dimension, children: [] }
        acc.push(dimensionObj)
      }

      let determinantObj = dimensionObj.children.find((d) => d.name === item.determinant)
      if (!determinantObj) {
        determinantObj = { name: item.determinant, children: [] }
        dimensionObj.children.push(determinantObj)
      }

      determinantObj.children.push({
        name: item.indicator_wrapped,
        evidence_val: item.evidence_val,
        level_agreement: item.level_agreement
      })

      return acc;
    }, [])

    const result = { name: ' ', children: nestedData }
    resolve(result)
  })
}

function createDendrogram(result) {
  const width = 1000;
  const marginTop = 40;
  const marginRight = 100;
  const marginBottom = 40;
  const marginLeft = width / 7;

  const root = d3.hierarchy(result);
  const dx = 35;
  const dy = (width - marginRight - marginLeft) / (1 + root.height);

  const tree = d3.tree().nodeSize([dx, dy]);

  if (mobileView){
    tree.separation(function(a,b) {
      if (a.parent === b.parent && (a.depth === 2 || a.depth === 3)){
        return 2;
      } else {
        return 1;
      }
    });
  }

  const diagonal = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);

  const svg = d3.select('#dendrogram-container')
    .append('svg')
    .attr('width', width)
    .attr('viewBox', [-marginLeft, -marginTop, width, dx])
    .style('max-width', '100%')
    .style('height', 'auto')
    .style('font-size', textSize)
    .style('font-weight', 600)
    .style('user-select', 'none');

  const gLink = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke', '#555')
    .attr('stroke-opacity', 0.4)
    .attr('stroke-width', 1.5);

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

  function update(event, source) {
    const duration = 1200;
    const nodes = root.descendants().reverse();
    const links = root.links().filter(link => link.source.depth !== 0);

    tree(root);

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + marginTop + marginBottom;

    const transition = svg.transition()
      .duration(duration)
      .attr('height', height)
      .attr('viewBox', [-marginLeft, left.x - marginTop, width, height])
      .tween('resize', window.ResizeObserver ? null : () => () => svg.dispatch('toggle'));

    const node = gNode.selectAll('g')
      .data(nodes, d => d.id);

    const nodeEnter = node.enter().append('g')
      .attr('transform', d => `translate(${source.y0},${source.x0})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0)
      .on('click', (event, d) => {
        d.children = d.children ? null : d._children;
        update(event, d);
      });

    nodeEnter.append('circle')
      .attr('r', d => {
        //console.log('Node data:', d); // Debugging
        return getNodeRadius(d);
      })
      .attr('fill', getNodeColor)
      .attr('stroke-width', 10);

    const wrapWidth = mobileView ? 100 : 175;

    const textElements = nodeEnter.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => d._children ? -6 : 6)
      .attr('text-anchor', d => d._children ? 'end' : 'start')
      .text(d => d.data.name)
      .style('fill', getNodeColor);

    textElements.filter(d => d.depth === 1)
      .clone(true).lower()
      .attr('stroke-linejoin', 'round')
      .attr('stroke-width', 3)
      .attr('stroke', 'white');

    textElements.filter(d => d.depth === 2 || d.depth === 3)
      .call(wrap, wrapWidth)
      .clone(true).lower()
      .attr('stroke-linejoin', 'round')
      .attr('stroke-width', 3)
      .attr('stroke', 'white');

    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .attr('fill-opacity', 1)
      .attr('stroke-opacity', 1);

    const nodeExit = node.exit().transition(transition).remove()
      .attr('transform', d => `translate(${source.y},${source.x})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0);

    const link = gLink.selectAll('path')
      .data(links, d => d.target.id);

    const linkEnter = link.enter().append('path')
      .attr('d', d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .attr('stroke-width', getLinkWidth)
      .attr('stroke', getLinkColor);

    link.merge(linkEnter).transition(transition)
      .attr('d', diagonal)
      .attr('stroke-width', getLinkWidth)
      .attr('stroke', getLinkColor);

    link.exit().transition(transition).remove()
      .attr('d', d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });

    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  root.x0 = ((width - marginRight - marginLeft) / (1 + root.height)) / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth !== 0) {
      d.children = null;
    }
  });
  update(null, root);
  return svg.node();
}

function wrap(text, width) {
  text.each(function() { 
    var text = d3.select(this),
      words = text.text().split(/\s+/).reverse(),
      word,
      line = [],
      lineNumber = 0,
      lineHeight = 1,
      x = text.attr('x'),
      y = text.attr('y'),
      dy = 0,
      tspan = text.text(null)
        .append('tspan')
        .attr('x', x)
        .attr('y', y)
        .attr('dy', dy + 'em');
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(' '));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(' '));
        line = [word];
        tspan = text.append('tspan')
          .attr('x', x)
          .attr('y', y)
          .attr('dy', ++lineNumber * lineHeight + dy + 'em')
          .text(word);
      }
    }
    var totalHeight = lineNumber * lineHeight;
    if (totalHeight > 0) {
      text.attr('y', y - totalHeight / 2);
    } else {
      text.attr('y', y + 5);
    }
  });
}

const colorScale = d3.scaleOrdinal()
  .domain(["Demographic characteristics", "Land tenure", "Living conditions", "Socioeconomic status", "Health", "Risk perception", "Exposure"])
  .range(Object.entries(dimensionColors).map(([key, value]) => value));

function getNodeColor(d) {
  if (d.depth === 1) {
    console.log(colorScale(d.data.name))
    return colorScale(d.data.name);
  } else if (d.parent && d.parent.depth === 1) {
    console.log(colorScale(d.parent.data.name))
    return colorScale(d.parent.data.name);
    console.log(colorScale(d.parent.data.name))
  } else if (d.parent && d.parent.parent && d.parent.parent.depth === 1) {
    console.log(colorScale(d.parent.parent.data.name))
    return colorScale(d.parent.parent.data.name);
    console.log(colorScale(d.parent.parent.data.name))
  } else {
    return 'transparent';
  }
}

function getLinkColor(d) {
  if (d.target.depth === 3) {
    return colorScale(d.target.parent.parent.data.name);
  } else if (d.target.depth === 2) {
    return colorScale(d.target.parent.data.name);
  } else if (d.target.depth === 1) {
    return colorScale(d.target.data.name);
  } else {
    return 'red';
  }
}

function getLinkWidth(d) {
  if (d.target.depth === 3) {
    return linkWidthScale(d.target.data.evidence_val);
  } else if (d.target.depth === 2) {
    return linkWidthScale(d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + child.evidence_val, 0) : 1.5);
  } else if (d.target.depth === 1) {
    return linkWidthScale(d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + (child.children ? child.children.reduce((acc, grandchild) => acc + grandchild.evidence_val, 0) : 0), 0) : 1.5);
  } else {
    return 1.5;
  }
}

function getNodeRadius(d) {
  if (d.depth === 3) {
    //console.log(d.data.evidence_val);
    return nodeRadiusScale(d.data.evidence_val);
  } else if (d.depth === 2) {
    let totalEvidence = getTotalEvidence(d);
    //console.log(totalEvidence);
    return nodeRadiusScale(totalEvidence);
  } else if (d.depth === 1) {
    let totalEvidence = getTotalEvidence(d);
    console.log(totalEvidence);
    return nodeRadiusScale(totalEvidence);
  } else {
    return 2.5;
  }
}

function getTotalEvidence(d) {
  if (d.children) {
    return d.children.reduce((acc, child) => {
      const childEvidence = getTotalEvidence(child);
      console.log('Child evidence:', childEvidence); // Debugging statement
      return acc + childEvidence;
    }, 0);
  } else {
    return d.data.evidence_val;
  }
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}
#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  text-align: center;
}

#dendrogram-container svg {
  display: inline-block;
}
</style>
