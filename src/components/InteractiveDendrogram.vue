<template>
  <section id="dendrogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="metaText.title" />
    </div>
    <div id="text1" class="text-container">
      <p v-html="metaText.paragraph1" />
    </div>
    <div id="dendrogram-container"></div>
    <div id="text2" class="text-container">
      <p v-html="metaText.paragraph2" />
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="metaText.paragraph3" />
    </div>
    <div id="text4" class="text-container">
      <p v-html="metaText.paragraph4" />
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3';
import text from '../assets/text/text.js';

const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
const metaText = text.components.metaAnalysisText;
let textSize;

const dimensionColors = {
  Demographiccharacteristics: "#092836",
  Landtenure: "#1b695e",
  Livingconditions: "#7a5195",
  Socioeconomicstatus: "#2a468f",
  Health: "#ef5675",
  Riskperception: "#ff764a",
  Exposure: "#ffa600"
};

onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      transformData().then(result => {
        calculateTextSize();
        createVerticalDendrogram(result);
      }).catch(error => {
        console.error('Error transforming data:', error);
      });
    }
  });
});

async function loadData() {
  data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', d => {
    d.level_agreement = +d.level_agreement;
    d.evidence_val = +d.evidence_val;
    return d;
  });
}

function calculateTextSize() {
  textSize = mobileView ? '1.5em' : '.85em';
}

function transformData() {
  return new Promise((resolve) => {
    const nestedData = data.value.reduce((acc, item) => {
      let dimensionObj = acc.find(d => d.name === item.dimension);
      if (!dimensionObj) {
        dimensionObj = { name: item.dimension, children: [] };
        acc.push(dimensionObj);
      }
      let determinantObj = dimensionObj.children.find(d => d.name === item.determinant);
      if (!determinantObj) {
        determinantObj = { name: item.determinant, children: [] };
        dimensionObj.children.push(determinantObj);
      }
      determinantObj.children.push({
        name: item.indicator_wrapped,
        positively_related_total: item.positively_related_total,
        negatively_related_total: item.negatively_related_total,
        unrelated_total: item.unrelated_total,
        unknown_direction_total: item.unknown_direction_total,
        evidence_val: item.evidence_val,
        level_agreement: item.level_agreement
      });
      determinantObj.children.sort((a, b) => b.evidence_val - a.evidence_val);
      return acc;
    }, []);

    resolve({ name: 'root', children: nestedData });
  });
}

function createVerticalDendrogram(data) {
  const width = 1000;
  const height = 1000;
  const margin = { top: 40, right: 90, bottom: 50, left: 90 };

  const treeLayout = d3.tree().size([height - margin.top - margin.bottom, width - margin.left - margin.right]);

  const root = d3.hierarchy(data);
  treeLayout(root);

  const svg = d3.select('#dendrogram-container')
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`)
    .style('font', `${textSize} sans-serif`)
    .style('user-select', 'none');

  const gLink = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke-opacity', 0.8)
    .attr('stroke-width', 1.5);

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

  // Define a scale for the radius of the nodes
  const radiusScale = d3.scaleSqrt()
    .domain(d3.extent(root.descendants(), d => d.data.evidence_val))
    .range([2.5, 15]);

  // Define a scale for the width of the links
  const widthScale = d3.scaleSqrt()
    .domain(d3.extent(root.descendants(), d => d.data.evidence_val))
    .range([1, 10]);

  let i = 0;

  // Initialize the display to show only level 1 and 2
  root.children.forEach(collapse);

  // Initial position for the root node
  root.x0 = height / 2;
  root.y0 = 0;

  update(root);

  function update(source) {
    const nodes = root.descendants();
    const links = root.links();

    const transition = svg.transition()
      .duration(750);

    // Update the links
    const link = gLink.selectAll('path')
      .data(links, d => d.target.id);

    const linkEnter = link.enter().append('path')
      .attr('d', d3.linkVertical()
        .x(d => d.y)
        .y(d => d.x))
      .attr('stroke', d => getLinkColor(d))
      .attr('stroke-width', d => widthScale(d.target.data.evidence_val))
      .attr('stroke-opacity', d => d.target.depth === 3 ? 0 : 1);

    link.merge(linkEnter).transition(transition)
      .attr('d', d3.linkVertical()
        .x(d => d.y)
        .y(d => d.x))
      .attr('stroke', d => getLinkColor(d))
      .attr('stroke-width', d => widthScale(d.target.data.evidence_val))
      .attr('stroke-opacity', d => d.target.depth === 3 ? 0 : 1);

    link.exit().transition(transition).remove()
      .attr('d', d3.linkVertical()
        .x(d => d.y)
        .y(d => d.x))
      .attr('stroke-opacity', 0);

    // Update the nodes
    const node = gNode.selectAll('g')
      .data(nodes, d => d.id || (d.id = ++i));

    const nodeEnter = node.enter().append('g')
      .attr('transform', d => `translate(${source.y0},${source.x0})`)
      .attr('fill-opacity', d => d.depth === 3 ? 0 : 1)
      .attr('stroke-opacity', d => d.depth === 3 ? 0 : 1)
      .on('click', (event, d) => {
        if (d.depth === 1) {
          d.children = d.children ? null : d._children;
          update(d);
        }
      });

    nodeEnter.append('circle')
      .attr('r', d => radiusScale(d.data.evidence_val))
      .attr('fill', getNodeColor);

    nodeEnter.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => {
        if (d.depth === 1) return d.children ? -6 : 6;
        if (d.depth === 2) return 6;
        return 6;
      })
      .attr('text-anchor', d => {
        if (d.depth === 1) return d.children ? 'start' : 'end';
        if (d.depth === 2) return 'start';
        return 'end';
      })
      .text(d => d.data.name)
      .attr('fill', getNodeColor);

    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .attr('fill-opacity', d => d.depth === 3 && !d.parent.children ? 0 : 1)
      .attr('stroke-opacity', d => d.depth === 3 && !d.parent.children ? 0 : 1);

    const nodeExit = node.exit().transition(transition).remove()
      .attr('transform', d => `translate(${source.y},${source.x})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0);

    // Stash the old positions for transition
    nodes.forEach(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }
}

const colorScale = d3.scaleOrdinal()
  .domain(["Demographic characteristics", "Land tenure", "Living conditions", "Socioeconomic status", "Health", "Risk perception", "Exposure"])
  .range(Object.values(dimensionColors));

function getNodeColor(d) {
  if (d.depth === 1) return colorScale(d.data.name);
  if (d.parent && d.parent.depth === 1) return colorScale(d.parent.data.name);
  if (d.parent && d.parent.parent && d.parent.parent.depth === 1) return colorScale(d.parent.parent.data.name);
  return 'transparent';
}

function getLinkColor(d) {
  if (d.source.depth === 0) return 'transparent';
  if (d.target.depth === 3) return colorScale(d.target.parent.parent.data.name);
  if (d.target.depth === 2) return colorScale(d.target.parent.data.name);
  if (d.target.depth === 1) return colorScale(d.target.data.name);
  return 'grey';
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}

#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  text-align: center;
}

#dendrogram-container svg {
  display: inline-block;
}
</style>
