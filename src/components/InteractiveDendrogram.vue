<template>
  <section id="dendrogram">
    <div id="title" class="text-container title-text">
      <h3 v-html="metaText.title" />
    </div>
    <div id="text1" class="text-container">
      <p v-html="metaText.paragraph1" />
    </div>
    <div id="dendrogram-container"></div>
    <div id="text2" class="text-container">
      <p v-html="metaText.paragraph2" />
    </div>
    <div id="text3" class="text-container quote">
      <p v-html="metaText.paragraph3" />
    </div>
    <div id="text4" class="text-container">
      <p v-html="metaText.paragraph4" />
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { isMobile } from 'mobile-device-detect';
import * as d3 from 'd3';
import text from '../assets/text/text.js';

const publicPath = import.meta.env.BASE_URL;
const data = ref([]);
const mobileView = isMobile;
const metaText = text.components.metaAnalysisText;
let textSize;

const dimensionColors = {
  Demographiccharacteristics: '#092836',
  Landtenure: '#2a468f',
  Livingconditions: '#7a5195',
  Socioeconomicstatus: '#1b695e',
  Health: '#ef5675',
  Riskperception: '#ff764a',
  Exposure: '#ffa600'
};

onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      transformData().then(result => {
        calculateTextSize();
        createDendrogram(result);
      }).catch(error => {
        console.error('Error transforming data:', error);
      });
    }
  });
});

async function loadData() {
  data.value = await d3.csv(publicPath + 'indicator_uncertainty.csv', d => {
    d.level_agreement = +d.level_agreement;
    d.evidence_val = +d.evidence_val;
    return d;
  });
}

function calculateTextSize() {
  textSize = mobileView ? '1.5em' : '.85em';
}

function transformData() {
  return new Promise((resolve) => {
    const nestedData = data.value.reduce((acc, item) => {
      let dimensionObj = acc.find(d => d.name === item.dimension);
      if (!dimensionObj) {
        dimensionObj = { name: item.dimension, children: [] };
        acc.push(dimensionObj);
      }
      let determinantObj = dimensionObj.children.find(d => d.name === item.determinant);
      if (!determinantObj) {
        determinantObj = { name: item.determinant, children: [] };
        dimensionObj.children.push(determinantObj);
      }
      determinantObj.children.push({
        name: item.indicator_wrapped,
        positively_related_total: item.positively_related_total,
        negatively_related_total: item.negatively_related_total,
        unrelated_total: item.unrelated_total,
        unknown_direction_total: item.unknown_direction_total,
        evidence_val: item.evidence_val,
        level_agreement: item.level_agreement
      });
      determinantObj.children.sort((a, b) => b.evidence_val - a.evidence_val);
      return acc;
    }, []);

    resolve({ name: ' ', children: nestedData });
  });
}

function createDendrogram(result) {
  const width = 1000;
  const margin = { top: 40, right: 40, bottom: 40, left: 40 };
  const root = d3.hierarchy(result);
  const dx = 35;
  const dy = (width - margin.right - margin.left) / (1 + root.height);
  const tree = d3.tree().nodeSize([dx, dy]);

  if (mobileView) {
    tree.separation((a, b) => (a.parent === b.parent && (a.depth === 2 || a.depth === 3)) ? 2 : 1);
  }

  const diagonal = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);

  const svg = d3.select('#dendrogram-container')
    .append('svg')
    .attr('width', width)
    .attr('height', dx)
    .attr('viewBox', [-margin.left, -margin.top, width, dx])
    .attr('style', `max-width: 100%; height: auto; font-size: ${textSize}; font-weight: 400; user-select: none;`);

  const gLink = svg.append('g')
    .attr('fill', 'none')
    .attr('stroke-opacity', 0.8)
    .attr('stroke-width', 1);

  const gNode = svg.append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

  function update(event, source) {
    const duration = event?.altKey ? 2000 : 1250;
    const nodes = root.descendants().reverse();
    const links = root.links().filter(link => link.source.depth !== 0);

    tree(root);

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + margin.top + margin.bottom;

    const transition = svg.transition()
      .duration(duration)
      .attr('height', height)
      .attr('viewBox', [-margin.left, left.x - margin.top, width, height])
      .tween('resize', window.ResizeObserver ? null : () => () => svg.dispatch('toggle'));

    const node = gNode.selectAll('g')
      .data(nodes, d => d.id);

    const nodeEnter = node.enter().append('g')
      .attr('transform', d => `translate(${source.y0},${source.x0})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0)
      .on('click', (event, d) => {
        d.children = d.children ? null : d._children;
        update(event, d);
      });

    nodeEnter.append('circle')
      .attr('r', 2.5)
      .attr('fill', getNodeColor)
      .attr('stroke-width', 10);

    const wrapWidth = mobileView ? 100 : 175;

    const textElements = nodeEnter.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => d._children ? -6 : 6)
      .attr('text-anchor', d => d._children ? 'end' : 'start')
      .text(d => d.data.name)
      .style('fill', getNodeColor);

    textElements.filter(d => d.depth === 1)
      .clone(true).lower()
      .attr('stroke-linejoin', 'round')
      .attr('stroke-width', 3)
      .attr('stroke', 'white');

    textElements.filter(d => d.depth === 2 || d.depth === 3)
      .call(wrap, wrapWidth)
      .clone(true).lower()
      .attr('stroke-linejoin', 'round')
      .attr('stroke-width', 3)
      .attr('stroke', 'white');

    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .attr('fill-opacity', 1)
      .attr('stroke-opacity', 1);

    const nodeExit = node.exit().transition(transition).remove()
      .attr('transform', d => `translate(${source.y},${source.x})`)
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0);

    const link = gLink.selectAll('path')
      .data(links, d => d.target.id);

    const linkEnter = link.enter().append('path')
      .attr('d', d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .attr('stroke-width', getLinkWidth)
      .attr('stroke', getLinkColor);

    link.merge(linkEnter).transition(transition)
      .attr('d', diagonal)
      .attr('stroke-width', getLinkWidth)
      .attr('stroke', getLinkColor);

    link.exit().transition(transition).remove()
      .attr('d', d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });

    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  root.x0 = ((width - margin.right - margin.left) / (1 + root.height)) / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth !== 0) {
      d.children = null;
    }
  });
  update(null, root);
}

function wrap(text, width) {
  text.each(function () {
    const text = d3.select(this),
      words = text.text().split(/\s+/).reverse(),
      line = [],
      lineHeight = 1,
      x = text.attr('x'),
      y = text.attr('y'),
      dy = 0,
      tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');
    let word;
    let lineNumber = 0;
    while ((word = words.pop())) {
      line.push(word);
      tspan.text(line.join(' '));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(' '));
        line = [word];
        tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
      }
    }
    const totalHeight = lineNumber * lineHeight;
    if (totalHeight > 0) {
      text.attr('y', y - totalHeight / 2);
    } else {
      text.attr('y', y + 5);
    }
  });
}

const colorScale = d3.scaleOrdinal()
  .domain(['Demographic characteristics', 'Exposure', 'Health', 'Land tenure', 'Living conditions', 'Risk perception', 'Socioeconomic status'])
  .range(Object.entries(dimensionColors).map(([key, value]) => value));

function getNodeColor(d) {
  if (d.depth === 1) return colorScale(d.data.name);
  if (d.parent && d.parent.depth === 1) return colorScale(d.parent.data.name);
  if (d.parent && d.parent.parent && d.parent.parent.depth === 1) return colorScale(d.parent.parent.data.name);
  return 'transparent';
}

function getLinkColor(d) {
  if (d.target.depth === 3) return colorScale(d.target.parent.parent.data.name);
  if (d.target.depth === 2) return colorScale(d.target.parent.data.name);
  if (d.target.depth === 1) return colorScale(d.target.data.name);
  return 'grey';
}

function getLinkWidth(d) {
  if (d.target.depth === 3) return d.target.data.evidence_val;
  if (d.target.depth === 2) return d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + child.evidence_val, 0) : 1.5;
  if (d.target.depth === 1) return d.target.data.children ? d.target.data.children.reduce((acc, child) => acc + (child.children ? child.children.reduce((acc, grandchild) => acc + grandchild.evidence_val, 0) : 0), 0) : 1.5;
  return 1;
}
</script>

<style scoped lang="scss">
.text-container {
  min-width: 30vw;
  max-width: 70rem;
  margin: 0 auto;
  padding: 1rem 1rem 1rem 0rem;
  left: 0;
  @media screen and (max-width: 600px) {
    max-width: 95vw;
    padding: 0.5rem;
  }
}

.title-text {
  width: 100%;
}

#dendrogram-container {
  pointer-events: none;
  grid-area: dendrogram;
  height: 100%;
  text-align: center;
}

#dendrogram-container svg {
  display: inline-block;
}
</style>
