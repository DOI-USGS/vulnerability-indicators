<template>
  <section id="dendogram">
    <div id="grid-container-interactive">
      <div id="title">
        <h3 class="grid-title">
          <p>Dendrogram Title</p>
        </h3>
      </div>
      <div id="text">
        <p>
          Dendogram might go here. Lorem ipsum dolor sit amet consectetur adipisicing elit. Nostrum
          doloremque sunt distinctio itaque dolorum ducimus provident minima mollitia recusandae!
        </p>
      </div>
      <div id="dendrogram-container"></div>
    </div>
  </section>
</template>

<script setup>
import { onMounted, ref } from 'vue'
import * as d3 from 'd3'

// global variables
const publicPath = import.meta.env.BASE_URL
const data = ref([])

// load data and then make chart
onMounted(() => {
  loadData().then(() => {
    if (data.value.length > 0) {
      transformData()
        .then((result) => {
          createDendrogram(result)
        })
        .catch((error) => {
          console.error('Error transforming data:', error)
        })
    }
  })
})

async function loadData() {
  // console.log(data);
  data.value = await d3.csv(publicPath + 'p2_agree_evid_stats.csv', (d) => {
    d.level_agreement = +d.level_agreement
    d.evidence_val = +d.evidence_val
    return d
  })
}

function transformData() {
  return new Promise((resolve, reject) => {
    const nestedData = data.value.reduce((acc, item) => {
      // check if dimension already exists in accumulator
      let dimensionObj = acc.find((d) => d.name === item.dimension)

      // if no dimension exists, create and add to acc
      if (!dimensionObj) {
        dimensionObj = {
          name: item.dimension,
          children: []
        }
        acc.push(dimensionObj)
      }

      // check if determinant already exists in dimension object
      let determinantObj = dimensionObj.children.find((d) => d.name === item.determinant)

      // iff not, create new determinant object and add to determinants array
      if (!determinantObj) {
        determinantObj = {
          name: item.determinant,
          children: []
        }
        dimensionObj.children.push(determinantObj)
      }

      // Add the current item to the indicators array
      determinantObj.children.push({
        name: item.indicator,
        positively_related_total: item.positively_related_total,
        negatively_related_total: item.negatively_related_total,
        unrelated_total: item.unrelated_total,
        unknown_direction_total: item.unknown_direction_total,
        unknown_total: item.unknown_total,
        significant_total: item.significant_total,
        not_significant_total: item.not_significant_total,
        evidence_val: item.evidence_val,
        sig_name: item.sig_name,
        sig_value: item.sig_value,
        level_agreement: item.level_agreement
      })

      // Sort the children array of determinantObj based on evidence_val in descending order
      // we may not want this
      determinantObj.children.sort((a, b) => b.evidence_val - a.evidence_val)

      return acc
    }, [])

    const result = {
      name: 'Click here',
      children: nestedData
    }
    console.log(result)
    resolve(result)
  })
}

function createDendrogram(result) {
  const width = 928
  const marginTop = 10
  const marginRight = 40
  const marginBottom = 10
  const marginLeft = 150

  // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
  // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
  // "bottom", in the data domain. The width of a column is based on the tree's height.
  // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
  // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
  // "bottom", in the data domain. The width of a column is based on the tree's height.
  const root = d3.hierarchy(result)
  const dx = 20
  const dy = (width - marginRight - marginLeft) / (1 + root.height)

  // Define the tree layout and the shape for links.
  const tree = d3.tree().nodeSize([dx, dy])
  const diagonal = d3.linkHorizontal()
    .x((d) => d.y)
    .y((d) => d.x)

  // Create the SVG container, a layer for the links and a layer for the nodes.
  const svg = d3
    .select('#dendrogram-container')
    .append('svg')
    .attr('width', width)
    .attr('height', dx)
    .attr('viewBox', [-marginLeft, -marginTop, width, dx])
    .attr(
      'style',
      "max-width: 100%; height: auto; font: 14px 'Source Sans Pro'; user-select: none;"
    )

  const gLink = svg
    .append('g')
    .attr('fill', 'none')
    .attr('stroke', '#555')
    .attr('stroke-opacity', 0.4)
    .attr('stroke-width', 1.5)

  const gNode = svg
    .append('g')
    .attr('cursor', 'pointer')
    .attr('pointer-events', 'all');

    function update(event, source) {
    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
    const nodes = root.descendants().reverse();
    const links = root.links();

    // Compute the new tree layout.
    tree(root);

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + marginTop + marginBottom;

    const transition = svg.transition()
      .duration(duration)
      .attr("height", height)
      .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
      .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

    // Update the nodes…
    const node = gNode.selectAll("g")
      .data(nodes, d => d.id);

    // Enter any new nodes at the parent's previous position.
    const nodeEnter = node.enter().append("g")
      .attr("transform", d => `translate(${source.y0},${source.x0})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0)
      .on("click", (event, d) => {
        d.children = d.children ? null : d._children;
        update(event, d);
      });

    nodeEnter.append("circle")
      .attr("r", 2.5)
      // .attr("fill", getNodeColor)
      .attr("stroke-width", 10);

    nodeEnter.append("text")
      .attr("dy", "0.31em")
      .attr("x", d => d._children ? -6 : 6)
      .attr("text-anchor", d => d._children ? "end" : "start")
      .text(d => d.data.name)
      // .style("fill", getNodeColor)
      .clone(true).lower()
      .attr("stroke-linejoin", "round")
      .attr("stroke-width", 3)
      .attr("stroke", "white");

    // Transition nodes to their new position.
    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr("transform", d => `translate(${d.y},${d.x})`)
      .attr("fill-opacity", 1)
      .attr("stroke-opacity", 1);

    // Transition exiting nodes to the parent's new position.
    const nodeExit = node.exit().transition(transition).remove()
      .attr("transform", d => `translate(${source.y},${source.x})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0);

    // Update the links…
    const link = gLink.selectAll("path")
      .data(links, d => d.target.id);

    // Enter any new links at the parent's previous position.
    const linkEnter = link.enter().append("path")
      .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .attr("stroke-width", d => {
        // Set the stroke width based on the evidence_val property of great-grandchildren
        if (d.target.depth === 3) {
          return d.target.data.evidence_val;
        } else {
          return 1.5; // Default stroke width for other nodes
        }
      })
      // .attr("stroke", getLinkColor); // Set the stroke color based on the target node's depth

    // Transition links to their new position.
    link.merge(linkEnter).transition(transition)
      .attr("d", diagonal)
      .attr("stroke-width", d => {
        // Set the stroke width based on the evidence_val property of great-grandchildren
        if (d.target.depth === 3) {
          return d.target.data.evidence_val;
        } else {
          return 1.5; // Default stroke width for other nodes
        }
      })
      // .attr("stroke", getLinkColor); // Set the stroke color based on the target node's depth

    // Transition exiting nodes to the parent's new position.
    link.exit().transition(transition).remove()
      .attr("d", d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });

    // Stash the old positions for transition.
    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  // Do the first update to the initial configuration of the tree — where only the root node is open.
  root.x0 = dy / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth) {
      d.children = null; // Set children to null for all nodes except the root
    }
  });
  update(null, root);

  return svg.node();
}
</script>

<style scoped lang="scss">
//  #grid-container-interactive {
//     display: grid;
//     padding: 20px 0 20px 0;
//     gap: 5px;
//     grid-template-columns: 65vw 25vw;
//     grid-template-rows: max-content max-content max-content max-content;
//     grid-template-areas:
//       "title title"
//       "text text"
//       "dendrogram dendrogram";
//     justify-content: center;
//     margin: auto;
//     max-width: 90vw;
//     min-width: 90vw;
//     // @media screen and (max-height: 770px) {
//     //   row-gap: 4vh;
//     //   margin: 4rem 0rem 5rem 0rem;
//     // }
//   }

//   #grid-title {
//     grid-area: title;
//     align-self: center;
//   }

//   #text {
//     grid-area: text;
//   }

//   #dendrogram-container {
//     pointer-events: none;
//     grid-area: map;
//     height: 100%;
//     max-height: 70vh;
//   }
#dendrogram-container {
  text-align: center;
  position: relative;
}

#dendrogram-container svg {
  // max-width: 100%;
  // max-height: 100%;
  // height: auto; /* Maintain aspect ratio */
  display: inline-block;
}
</style>
