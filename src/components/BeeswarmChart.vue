<template>
    <div
      id="grid-container-interactive"
    >
        <div id="state-dropdown-container" />
        <div id="chart-container">
        </div>
    </div>
</template>
  
<script setup>
    import { onMounted, ref } from "vue";
    import * as d3 from 'd3';

    // global variables 
    const publicPath = import.meta.env.BASE_URL;
    let chartData;
    let dataTypes;
    let chartDimensions;
    let chartBounds;
    let xScale;
    const focalColor = "#d66853";
    const defaultColor = "#7d4e57";
    
    // Declare behavior on mounted
    // functions called here
    onMounted(() => {
        loadData();
    });

    // Functions
    function loadData() {
        let promises = [
        d3.csv(publicPath + 'indicator_uncertainty.csv'),
      ];
      Promise.all(promises).then(callback)
    }

    function callback(data) {
        chartData = data[0];
        dataTypes = [... new Set(chartData.map(d => d.dimension))]

        initChart();
        drawChart(chartData);
    }

    function initChart() {

        // define histogram dimensions relative to container dimensions
        const desktopWidth = 2800;
        const desktopHeight = window.innerHeight //* .75;

        chartDimensions = {
            width: desktopWidth,
            height: desktopHeight,
            margin: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
            }
        }
        chartDimensions.boundedWidth = chartDimensions.width - chartDimensions.margin.left - chartDimensions.margin.right
        chartDimensions.boundedHeight = chartDimensions.height - chartDimensions.margin.top - chartDimensions.margin.bottom
        
        // draw canvas for histogram
        const chartSVG = d3.select("#chart-container")
            .append("svg")
            .attr("viewBox", [0, 0, (chartDimensions.width), (chartDimensions.height)].join(' '))
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("id", "chart-svg")

        // assign role for accessibility
        chartSVG.attr("role", "figure")
            .attr("tabindex", 0)
            .append("title")

        chartBounds = chartSVG.append("g")
            .style("transform", `translate(${
            chartDimensions.margin.left
            }px, ${
            chartDimensions.margin.top
            }px)`)

        // Y axis
        // scale for the y-axis
       // yScale = d3.scaleBand()
       //     .domain(dataTypes)
       //     .range([0, chartDimensions.boundedHeight])
        //    .padding(0);
    }
    function drawChart(data) {
        //let data = chartData;
        const margin = ({ top: 10, right: 20, bottom: 30, left: 20 })
        const height = 720
        const width = 1200

        const xMin = d3.min(data, d => d.level_agreement);
        const xMax = d3.max(data, d => d.level_agreement);

        xScale = d3.scaleLinear()
            .range([0, width - margin.left - margin.right])
            .domain([xMin-1, xMax+1])
        const xAxis = d3.axisBottom(xScale).ticks(20)
       simulation(data, height)

       xScale.ticks()


    

        

        console.log(chartData)

    }
    function simulation(data, height){
        const simulationForceColide = 33
        const sim = d3.forceSimulation(data)
            .force("x", d3.forceX(d => xScale(d.value)).strength(0.75))
            .force("y", d3.forceY(height / 2))
            .force("collide", d3.forceCollide(simulationForceColide))
            .stop()
        
        for (let i = 0; i < 120; ++i) {
            sim.tick();
        }
        
        return sim
    }
    function xGrid(g){
        g
        .attr('class', 'grid-lines')
        .selectAll('line')
        .data(xScale.ticks())
        .join('line')
        .attr('x1', d => xScale(d))
        .attr('x2', d => xScale(d))
        .attr('y1', margin.top)
        .attr('y2', height - margin.bottom)
        .style('stroke', "#E7E7E7")
    }
    function drawCharty() {
        let data = chartData;
        // accessor functions
        const yAccessor = d => d.evidence_val
        const xAccessor = d => d.level_agreement //
        const colorAccessor = d => d.dimension
        const identifierAccessor = d => d.dimension.replace(' ', '-')

        // create x scale
        const xScale = d3.scaleLinear()
            .domain([0, d3.max(data, xAccessor)]) 
            .range([0, chartDimensions.boundedWidth])
            .nice()

        const yScale = d3.scaleLinear()
            .domain([0, d3.max(data, yAccessor)]) 
            .range([chartDimensions.boundedHeight, 0])
            .nice()

        const rScale = d3.scaleSqrt()
            .domain(d3.extent(data, d => d.evidence_val))
            .range([1, 50]);
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        const simulation = d3.forceSimulation(data)
        .force("x", d3.forceX(d => xScale(d.agreement)).strength(0.5))
        .force("y", d3.forceY(chartDimensions.boundedHeight / 2))
        .force("collide", d3.forceCollide(d => rScale(d.evidence_val)))
        .stop();

        for (let i = 0; i < 120; ++i) simulation.tick();

        chartBounds.selectAll("circle")
        .data(data)
        .join("circle")
          .attr("cy", chartDimensions.width / 2)
          .attr("cx", d => xScale(d.agreement))
          .attr("r", d => rScale(d.evidence_val))
          .attr("fill", d => colorScale(d.dimension));

    }
</script>
  
<style scoped lang="scss">
    #grid-container-interactive {
        display: grid;
        grid-template-columns: 100%;
        grid-template-rows: max-content max-content;
        grid-template-areas:
            "chart";
        justify-items: start;
        margin: 3rem auto 5rem auto;
        width: 95vw;
    }
    #chart-container {
        grid-area: chart;
        height: 80vh;
        background-color: purple;
    }

    
</style>

<style lang="scss">
    .dropdown {
        transition: width 1s, transform 1s;
    }
    .chart-text {
        user-select: none;
    }
</style>
  